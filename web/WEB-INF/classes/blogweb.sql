/*
Navicat MySQL Data Transfer

Source Server         : User_localhost
Source Server Version : 80015
Source Host           : localhost:3306
Source Database       : blogweb

Target Server Type    : MYSQL
Target Server Version : 80015
File Encoding         : 65001

Date: 2020-07-23 16:58:47
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for article_info
-- ----------------------------
DROP TABLE IF EXISTS `article_info`;
CREATE TABLE `article_info` (
  `a_id` int(11) NOT NULL AUTO_INCREMENT,
  `a_title` varchar(255) NOT NULL,
  `a_cid` int(255) DEFAULT NULL,
  `a_context_md` longtext,
  `a_context` longtext,
  `a_ldate` varchar(255) DEFAULT NULL,
  `a_date` varchar(255) DEFAULT NULL,
  `a_del` int(1) NOT NULL DEFAULT '0',
  PRIMARY KEY (`a_id`),
  KEY `a_cid` (`a_cid`),
  CONSTRAINT `a_cid` FOREIGN KEY (`a_cid`) REFERENCES `class_info` (`class_id`)
) ENGINE=InnoDB AUTO_INCREMENT=82 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of article_info
-- ----------------------------
INSERT INTO `article_info` VALUES ('1', 'HelloWorld', '1', '# HelloWorld!', '<p>HelloWorld!</p>', '2020-07-01', '2020-07-01', '0');
INSERT INTO `article_info` VALUES ('2', 'About', '1', '> 欢迎来到我的小站，很高兴遇见你！:fa-heart:\n\n##关于本站\n\n- 本站使用Java+Jsp+Js+css+h5搭建\n\n##博主是谁\n\n- 生产实习7组成员\n\n##联系方式\n\n-:fa-envelope-o: Email：hub717@outlook.com\n-:fa-user: 微信：717hub\n-:fa-phone: 电话：123566\n-:fa-plus: [坐标点这里](https://ditu.amap.com/search?query=青岛&city=370100&geoobj=116.819305|36.568757|117.292404|36.788207&zoom=12)', '<blockquote>\n<p>欢迎来到我的小站，很高兴遇见你！<i class=\"fa fa-heart fa-emoji\" title=\"heart\"></i></p>\n</blockquote>\n<h2 id=\"h2-u5173u4E8Eu672Cu7AD9\"><a name=\"关于本站\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>关于本站</h2><ul>\n<li>本站使用Java+Jsp+Js+css+h5搭建</li></ul>\n<h2 id=\"h2-u535Au4E3Bu662Fu8C01\"><a name=\"博主是谁\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>博主是谁</h2><ul>\n<li>生产实习7组成员</li></ul>\n<h2 id=\"h2-u8054u7CFBu65B9u5F0F\"><a name=\"联系方式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>联系方式</h2><p>-<i class=\"fa fa-envelope-o fa-emoji\" title=\"envelope-o\"></i> Email：<a href=\"mailto:hub717@outlook.com\">hub717@outlook.com</a><br>-<i class=\"fa fa-user fa-emoji\" title=\"user\"></i> 微信：717hub<br>-<i class=\"fa fa-phone fa-emoji\" title=\"phone\"></i> 电话：123566<br>-<i class=\"fa fa-plus fa-emoji\" title=\"plus\"></i> <a href=\"https://ditu.amap.com/search?query=青岛&amp;city=370100&amp;geoobj=116.819305|36.568757|117.292404|36.788207&amp;zoom=12\">坐标点这里</a></p>\n', '2020-07-23', '2020-07-23', '1');
INSERT INTO `article_info` VALUES ('68', '《热风》', '53', '# 《热风》-节选\n\n所以我时常害怕，愿中国青年都摆脱冷气，只是向上走，不必听自暴自弃者流的话。能做事的做事，能发声的发声。有一分热，发一分光，就令萤火一般，也可以在黑暗里发一点光，不必等候炬火。\n\n此后如竟没有炬火：我便是唯一的光。倘若有了炬火，出了太阳，我们自然心悦诚服的消失，不但毫无不平，而且还要随喜赞美这炬火或太阳；因为他照了人类，连我都在内。我又愿中国青年都只是向上走，不必理会这冷笑和暗箭。\n\n尼采说：\n“真的，人是一个浊流。应该是海了，能容这浊流使他干净。\n“咄，我教你们超人：这便是海，在他这里，能容下你们的大侮蔑。”（《札拉图如是说》的《序言》第三节）\n\n纵令不过一洼浅水，也可以学学大海；横竖都是水，可以相通。几粒石子，任他们暗地里掷来；几滴秽水，任他们从背后泼来就是了。这还算不到“大侮蔑”——因为大侮蔑也须有胆力。\n', '<h1 id=\"h1--\"><a name=\"《热风》-节选\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>《热风》-节选</h1><p>所以我时常害怕，愿中国青年都摆脱冷气，只是向上走，不必听自暴自弃者流的话。能做事的做事，能发声的发声。有一分热，发一分光，就令萤火一般，也可以在黑暗里发一点光，不必等候炬火。</p>\n<p>此后如竟没有炬火：我便是唯一的光。倘若有了炬火，出了太阳，我们自然心悦诚服的消失，不但毫无不平，而且还要随喜赞美这炬火或太阳；因为他照了人类，连我都在内。我又愿中国青年都只是向上走，不必理会这冷笑和暗箭。</p>\n<p>尼采说：<br>“真的，人是一个浊流。应该是海了，能容这浊流使他干净。<br>“咄，我教你们超人：这便是海，在他这里，能容下你们的大侮蔑。”（《札拉图如是说》的《序言》第三节）</p>\n<p>纵令不过一洼浅水，也可以学学大海；横竖都是水，可以相通。几粒石子，任他们暗地里掷来；几滴秽水，任他们从背后泼来就是了。这还算不到“大侮蔑”——因为大侮蔑也须有胆力。</p>\n', '2020-07-20', '2020-07-20', '0');
INSERT INTO `article_info` VALUES ('69', '二叉树', '54', '> 整理自leetcode\n>\n> 树结点定义如下：\n>\n> ```c\n> Definition for a binary tree node.\n> struct TreeNode {\n>     int val;\n>     struct TreeNode *left;\n>     struct TreeNode *right;\n> };\n> ```\n>\n> \n\n## 二叉树的最大深度\n\n给定一个二叉树，找出其最大深度。\n\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n\n**说明:** 叶子节点是指没有子节点的节点。\n\n**示例：**\n给定二叉树 `[3,9,20,null,null,15,7]`，\n\n```\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n```\n\n返回它的最大深度 3 。\n\n**代码**:\n\n```c\nint maxDepth(struct TreeNode *root) {\n	\n	int ld = 0;\n	int rd = 0;\n	if (NULL == root) return 0;\n	if (root->left) ld = maxDepth(root->left);	// 左子树存在进行左递归\n	if (root->right) rd = maxDepth(root->right);	// 右子树存在进行右递归\n	return 1 + ((ld > rd) ? ld : rd);		// 本层递归结束比较左右子树的深度取大者相加\n}\n```\n\n## 对称二叉树\n\n给定一个二叉树，检查它是否是镜像对称的。\n\n例如，二叉树 `[1,2,2,3,4,4,3]` 是对称的。\n\n```\n    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3\n```\n\n但是下面这个 `[1,2,2,null,3,null,3]` 则不是镜像对称的:\n\n```\n    1\n   / \\\n  2   2\n   \\   \\\n   3    3\n```\n\n**代码**:\n\n```c\nbool recursion(struct TreeNode* left, struct TreeNode* right) {\n	\n	// 如果左子树和右子树均为空 返回真\n	if (NULL == left && NULL == right) return true;\n	else if (left == NULL || right == NULL) {\n		// 其中一个不为空 返回假\n		return false;\n	}\n\n	// 左结点的值是否等于右结点的值\n	bool c1 = (left->val == right->val);\n	// 左结点的左子树是否等于右结点的右子树\n	bool c2 = recursion(left->left, right->right);\n	// 左结点的右子树是否等于右结点的左子树\n	bool c3 = recursion(left->right, right->left);\n	// 如果同时成立\n	if (c1&&c2&&c3) {\n		return true;\n	}\n	else {\n		return false;\n	}\n}\n\nbool isSymmetric(struct TreeNode* root) {\n	// 根 为空 返回正确\n	if (root == NULL) {\n		return true;\n	}\n	return recursion(root->left, root->right);\n}\n```\n\n## 路径总和\n\n给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。\n\n**说明:** 叶子节点是指没有子节点的节点。\n\n**示例:** \n给定如下二叉树，以及目标和 `sum = 22`，\n\n```\n              5\n             / \\\n            4   8\n           /   / \\\n          11  13  4\n         /  \\      \\\n        7    2      1\n```\n\n返回 `true`, 因为存在目标和为 22 的根节点到叶子节点的路径 `5->4->11->2`。\n\n**代码**:\n\n```c\nbool hasPathSum(struct TreeNode* root, int sum) {\n\n	if (NULL == root) return false;\n\n	// 保证该结点为叶子结点的前提下 ，判断此时的sum是否和结点的值相等\n	if (root->val == sum && NULL == root->left && NULL == root->right)\n		return true;\n\n	// 递归向下层遍历，出错直接执行 false\n	if (hasPathSum(root->left, sum - root->val) || hasPathSum(root->right, sum - root->val))\n		return true;\n\n	return false;\n\n}\n```\n\n', '<blockquote>\n<p>整理自leetcode</p>\n<p>树结点定义如下：</p>\n<pre><code class=\"lang-c\">Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    struct TreeNode *left;\n    struct TreeNode *right;\n};\n</code></pre>\n</blockquote>\n<h2 id=\"h2-u4E8Cu53C9u6811u7684u6700u5927u6DF1u5EA6\"><a name=\"二叉树的最大深度\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二叉树的最大深度</h2><p>给定一个二叉树，找出其最大深度。</p>\n<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>\n<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>\n<p><strong>示例：</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p>\n<pre><code>    3\n   / \\\n  9  20\n    /  \\\n   15   7\n</code></pre><p>返回它的最大深度 3 。</p>\n<p><strong>代码</strong>:</p>\n<pre><code class=\"lang-c\">int maxDepth(struct TreeNode *root) {\n\n    int ld = 0;\n    int rd = 0;\n    if (NULL == root) return 0;\n    if (root-&gt;left) ld = maxDepth(root-&gt;left);    // 左子树存在进行左递归\n    if (root-&gt;right) rd = maxDepth(root-&gt;right);    // 右子树存在进行右递归\n    return 1 + ((ld &gt; rd) ? ld : rd);        // 本层递归结束比较左右子树的深度取大者相加\n}\n</code></pre>\n<h2 id=\"h2-u5BF9u79F0u4E8Cu53C9u6811\"><a name=\"对称二叉树\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>对称二叉树</h2><p>给定一个二叉树，检查它是否是镜像对称的。</p>\n<p>例如，二叉树 <code>[1,2,2,3,4,4,3]</code> 是对称的。</p>\n<pre><code>    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3\n</code></pre><p>但是下面这个 <code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p>\n<pre><code>    1\n   / \\\n  2   2\n   \\   \\\n   3    3\n</code></pre><p><strong>代码</strong>:</p>\n<pre><code class=\"lang-c\">bool recursion(struct TreeNode* left, struct TreeNode* right) {\n\n    // 如果左子树和右子树均为空 返回真\n    if (NULL == left &amp;&amp; NULL == right) return true;\n    else if (left == NULL || right == NULL) {\n        // 其中一个不为空 返回假\n        return false;\n    }\n\n    // 左结点的值是否等于右结点的值\n    bool c1 = (left-&gt;val == right-&gt;val);\n    // 左结点的左子树是否等于右结点的右子树\n    bool c2 = recursion(left-&gt;left, right-&gt;right);\n    // 左结点的右子树是否等于右结点的左子树\n    bool c3 = recursion(left-&gt;right, right-&gt;left);\n    // 如果同时成立\n    if (c1&amp;&amp;c2&amp;&amp;c3) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\nbool isSymmetric(struct TreeNode* root) {\n    // 根 为空 返回正确\n    if (root == NULL) {\n        return true;\n    }\n    return recursion(root-&gt;left, root-&gt;right);\n}\n</code></pre>\n<h2 id=\"h2-u8DEFu5F84u603Bu548C\"><a name=\"路径总和\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>路径总和</h2><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p>\n<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>\n<p><strong>示例:</strong><br>给定如下二叉树，以及目标和 <code>sum = 22</code>，</p>\n<pre><code>              5\n             / \\\n            4   8\n           /   / \\\n          11  13  4\n         /  \\      \\\n        7    2      1\n</code></pre><p>返回 <code>true</code>, 因为存在目标和为 22 的根节点到叶子节点的路径 <code>5-&gt;4-&gt;11-&gt;2</code>。</p>\n<p><strong>代码</strong>:</p>\n<pre><code class=\"lang-c\">bool hasPathSum(struct TreeNode* root, int sum) {\n\n    if (NULL == root) return false;\n\n    // 保证该结点为叶子结点的前提下 ，判断此时的sum是否和结点的值相等\n    if (root-&gt;val == sum &amp;&amp; NULL == root-&gt;left &amp;&amp; NULL == root-&gt;right)\n        return true;\n\n    // 递归向下层遍历，出错直接执行 false\n    if (hasPathSum(root-&gt;left, sum - root-&gt;val) || hasPathSum(root-&gt;right, sum - root-&gt;val))\n        return true;\n\n    return false;\n\n}\n</code></pre>\n', '2020-07-22', '2020-07-22', '0');
INSERT INTO `article_info` VALUES ('70', 'matplotlib中pyplot颜色映射参数整理', '55', '```python\nimport numpy as np  \nimport matplotlib.pyplot as plt  \n\n# Have colormaps separated into categories:  \n# http://matplotlib.org/examples/color/colormaps_reference.html  \n\ncmaps = [(\'Perceptually Uniform Sequential\',  \n                            [\'viridis\', \'inferno\', \'plasma\', \'magma\']),  \n         (\'Sequential\',     [\'Blues\', \'BuGn\', \'BuPu\',  \n                             \'GnBu\', \'Greens\', \'Greys\', \'Oranges\', \'OrRd\',  \n                             \'PuBu\', \'PuBuGn\', \'PuRd\', \'Purples\', \'RdPu\',  \n                             \'Reds\', \'YlGn\', \'YlGnBu\', \'YlOrBr\', \'YlOrRd\']),  \n         (\'Sequential (2)\', [\'afmhot\', \'autumn\', \'bone\', \'cool\',  \n                             \'copper\', \'gist_heat\', \'gray\', \'hot\',  \n                             \'pink\', \'spring\', \'summer\', \'winter\']),  \n         (\'Diverging\',      [\'BrBG\', \'bwr\', \'coolwarm\', \'PiYG\', \'PRGn\', \'PuOr\',  \n                             \'RdBu\', \'RdGy\', \'RdYlBu\', \'RdYlGn\', \'Spectral\',  \n                             \'seismic\']),  \n         (\'Qualitative\',    [\'Accent\', \'Dark2\', \'Paired\', \'Pastel1\',  \n                             \'Pastel2\', \'Set1\', \'Set2\', \'Set3\']),  \n         (\'Miscellaneous\',  [\'gist_earth\', \'terrain\', \'ocean\', \'gist_stern\',  \n                             \'brg\', \'CMRmap\', \'cubehelix\',  \n                             \'gnuplot\', \'gnuplot2\', \'gist_ncar\',  \n                             \'nipy_spectral\', \'jet\', \'rainbow\',  \n                             \'gist_rainbow\', \'hsv\', \'flag\', \'prism\'])]  \n\n\nnrows = max(len(cmap_list) for cmap_category, cmap_list in cmaps)  \ngradient = np.linspace(0, 1, 256)  \ngradient = np.vstack((gradient, gradient))  \n\n\ndef plot_color_gradients(cmap_category, cmap_list):  \n    fig, axes = plt.subplots(nrows=nrows)  \n    fig.subplots_adjust(top=0.95, bottom=0.01, left=0.2, right=0.99)  \n    axes[0].set_title(cmap_category + \' colormaps\', fontsize=14)  \n\n    for ax, name in zip(axes, cmap_list):  \n        ax.imshow(gradient, aspect=\'auto\', cmap=plt.get_cmap(name))  \n        pos = list(ax.get_position().bounds)  \n        x_text = pos[0] - 0.01  \n        y_text = pos[1] + pos[3]/2.  \n        fig.text(x_text, y_text, name, va=\'center\', ha=\'right\', fontsize=10)  \n\n    # Turn off *all* ticks & spines, not just the ones with colormaps.  \n    for ax in axes:  \n        ax.set_axis_off()  \n\nfor cmap_category, cmap_list in cmaps:  \n    plot_color_gradients(cmap_category, cmap_list)  \n\nplt.show() \n```\n\n这样，我们得到matplotlib中内嵌的colormaps：\n\n![](https://i.loli.net/2019/02/09/5c5e494361671.png)\n\n![](https://i.loli.net/2019/02/09/5c5e49659d6f3.png)\n\n![](https://i.loli.net/2019/02/09/5c5e497343d9d.png)\n\n![](https://i.loli.net/2019/02/09/5c5e4983a1c9b.png)\n\n![](https://i.loli.net/2019/02/09/5c5e4998033d1.png)\n\n![](https://i.loli.net/2019/02/09/5c5e49b3ee6f0.png)\n\n\n\n> 或者访问 http://matplotlib.org/    -> Examples  -> Color Examples  ->  colormaps_reference', '<pre><code class=\"lang-python\">import numpy as np  \nimport matplotlib.pyplot as plt  \n\n# Have colormaps separated into categories:  \n# http://matplotlib.org/examples/color/colormaps_reference.html  \n\ncmaps = [(&#39;Perceptually Uniform Sequential&#39;,  \n                            [&#39;viridis&#39;, &#39;inferno&#39;, &#39;plasma&#39;, &#39;magma&#39;]),  \n         (&#39;Sequential&#39;,     [&#39;Blues&#39;, &#39;BuGn&#39;, &#39;BuPu&#39;,  \n                             &#39;GnBu&#39;, &#39;Greens&#39;, &#39;Greys&#39;, &#39;Oranges&#39;, &#39;OrRd&#39;,  \n                             &#39;PuBu&#39;, &#39;PuBuGn&#39;, &#39;PuRd&#39;, &#39;Purples&#39;, &#39;RdPu&#39;,  \n                             &#39;Reds&#39;, &#39;YlGn&#39;, &#39;YlGnBu&#39;, &#39;YlOrBr&#39;, &#39;YlOrRd&#39;]),  \n         (&#39;Sequential (2)&#39;, [&#39;afmhot&#39;, &#39;autumn&#39;, &#39;bone&#39;, &#39;cool&#39;,  \n                             &#39;copper&#39;, &#39;gist_heat&#39;, &#39;gray&#39;, &#39;hot&#39;,  \n                             &#39;pink&#39;, &#39;spring&#39;, &#39;summer&#39;, &#39;winter&#39;]),  \n         (&#39;Diverging&#39;,      [&#39;BrBG&#39;, &#39;bwr&#39;, &#39;coolwarm&#39;, &#39;PiYG&#39;, &#39;PRGn&#39;, &#39;PuOr&#39;,  \n                             &#39;RdBu&#39;, &#39;RdGy&#39;, &#39;RdYlBu&#39;, &#39;RdYlGn&#39;, &#39;Spectral&#39;,  \n                             &#39;seismic&#39;]),  \n         (&#39;Qualitative&#39;,    [&#39;Accent&#39;, &#39;Dark2&#39;, &#39;Paired&#39;, &#39;Pastel1&#39;,  \n                             &#39;Pastel2&#39;, &#39;Set1&#39;, &#39;Set2&#39;, &#39;Set3&#39;]),  \n         (&#39;Miscellaneous&#39;,  [&#39;gist_earth&#39;, &#39;terrain&#39;, &#39;ocean&#39;, &#39;gist_stern&#39;,  \n                             &#39;brg&#39;, &#39;CMRmap&#39;, &#39;cubehelix&#39;,  \n                             &#39;gnuplot&#39;, &#39;gnuplot2&#39;, &#39;gist_ncar&#39;,  \n                             &#39;nipy_spectral&#39;, &#39;jet&#39;, &#39;rainbow&#39;,  \n                             &#39;gist_rainbow&#39;, &#39;hsv&#39;, &#39;flag&#39;, &#39;prism&#39;])]  \n\n\nnrows = max(len(cmap_list) for cmap_category, cmap_list in cmaps)  \ngradient = np.linspace(0, 1, 256)  \ngradient = np.vstack((gradient, gradient))  \n\n\ndef plot_color_gradients(cmap_category, cmap_list):  \n    fig, axes = plt.subplots(nrows=nrows)  \n    fig.subplots_adjust(top=0.95, bottom=0.01, left=0.2, right=0.99)  \n    axes[0].set_title(cmap_category + &#39; colormaps&#39;, fontsize=14)  \n\n    for ax, name in zip(axes, cmap_list):  \n        ax.imshow(gradient, aspect=&#39;auto&#39;, cmap=plt.get_cmap(name))  \n        pos = list(ax.get_position().bounds)  \n        x_text = pos[0] - 0.01  \n        y_text = pos[1] + pos[3]/2.  \n        fig.text(x_text, y_text, name, va=&#39;center&#39;, ha=&#39;right&#39;, fontsize=10)  \n\n    # Turn off *all* ticks &amp; spines, not just the ones with colormaps.  \n    for ax in axes:  \n        ax.set_axis_off()  \n\nfor cmap_category, cmap_list in cmaps:  \n    plot_color_gradients(cmap_category, cmap_list)  \n\nplt.show()\n</code></pre>\n<p>这样，我们得到matplotlib中内嵌的colormaps：</p>\n<p><img src=\"https://i.loli.net/2019/02/09/5c5e494361671.png\" alt=\"\"></p>\n<p><img src=\"https://i.loli.net/2019/02/09/5c5e49659d6f3.png\" alt=\"\"></p>\n<p><img src=\"https://i.loli.net/2019/02/09/5c5e497343d9d.png\" alt=\"\"></p>\n<p><img src=\"https://i.loli.net/2019/02/09/5c5e4983a1c9b.png\" alt=\"\"></p>\n<p><img src=\"https://i.loli.net/2019/02/09/5c5e4998033d1.png\" alt=\"\"></p>\n<p><img src=\"https://i.loli.net/2019/02/09/5c5e49b3ee6f0.png\" alt=\"\"></p>\n<blockquote>\n<p>或者访问 <a href=\"http://matplotlib.org/\">http://matplotlib.org/</a>    -&gt; Examples  -&gt; Color Examples  -&gt;  colormaps_reference</p>\n</blockquote>\n', '2020-07-22', '2020-07-20', '0');
INSERT INTO `article_info` VALUES ('71', '正则表达式', '53', '> 本篇主要介绍Python正则表达式的re库的基本使用方法。\n>\n> 本篇主要内容的整理来自于：\n>\n> [Python-re库的官方文档](<https://docs.python.org/zh-cn/3/library/re.html>)\n>\n> [Python-0-100天正则表达式部分]([https://github.com/jackfrued/Python-100-Days/blob/master/Day01-15/12.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.md](https://github.com/jackfrued/Python-100-Days/blob/master/Day01-15/12.字符串和正则表达式.md))\n>\n> [正则表达式30分钟入门](<https://deerchao.net/tutorials/regex/regex.htm>)\n\n# 什么是正则表达式\n\n在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。**正则表达式**就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。\n\n换句话说正则表达式是一种工具，它定义了字符串的匹配模式（如何检查一个字符串是否有跟某种模式匹配的部分或者从一个字符串中将与模式匹配的部分提取出来或者替换掉）。如果你在Windows操作系统中使用过文件查找并且在指定文件名时使用过通配符（*和?），那么正则表达式也是与之类似的用来进行文本匹配的工具，只不过比起通配符正则表达式更强大，它能更精确地描述你的需求（当然你付出的代价是书写一个正则表达式比打出一个通配符要复杂得多，要知道任何给你带来好处的东西都是有代价的，就如同学习一门编程语言一样），比如你可以编写一个正则表达式，用来查找所有以0开头，后面跟着2-3个数字，然后是一个连字号“-”，最后是7或8位数字的字符串（像028-12345678或0813-7654321），这不就是国内的座机号码吗。最初计算机是为了做数学运算而诞生的，处理的信息基本上都是数值，而今天我们在日常工作中处理的信息基本上都是文本数据，我们希望计算机能够识别和处理符合某些模式的文本，正则表达式就显得非常重要了。今天几乎所有的编程语言都提供了对正则表达式操作的支持，Python通过标准库中的re模块来支持正则表达式操作。\n\n我们可以考虑下面一个问题：我们从某个地方（可能是一个文本文件，也可能是网络上的一则新闻）获得了一个字符串，希望在字符串中找出手机号和座机号。当然我们可以设定手机号是11位的数字（注意并不是随机的11位数字，因为你没有见过“25012345678”这样的手机号吧）而座机号跟上一段中描述的模式相同，如果不使用正则表达式要完成这个任务就会很麻烦。\n\n\n\n# 正则表达式中的基本符号扼要总结\n\n## 匹配类型\n\n| 符号 | 解释                         | 示例      | 说明                                        |\n| :--- | :--------------------------- | :-------- | :------------------------------------------ |\n| .    | 匹配任意字符                 | b.t       | 可以匹配bat/but/b#t/b2t等                   |\n| \\w   | 匹配字母/数字/下划线         | b\\wt      | 可以匹配bat/but/b_t等 但是不能匹配b#t       |\n| \\s   | 匹配空白字符(包括\\t、\\n、\\r) | love\\syou | 可以匹配love you                            |\n| \\d   | 匹配数字                     | \\d\\d      | 可以匹配01/99/34/54等                       |\n| \\b   | 匹配单词的边界               | \\bThe\\b   |                                             |\n| ^    | 匹配字符串的开始             | ^The      | 可以匹配The开头的字符串                     |\n| $    | 匹配字符串的结束             | $.exe     | 可以匹配.exe结束的字符串                    |\n| \\W   | 匹配非(字母/数字/下划线)     | b\\Wt      | 可以匹配b@t/b#t等 但是不能匹配b1t/but/b_t等 |\n| \\S   | 匹配非空白字符               | love\\Syou | 可以匹配love#you等 但是不能匹配love you     |\n| \\D   | 匹配非数字                   | \\d\\D      | 可以匹配3#/5f/6^等                          |\n| \\B   | 匹配非单词边界               | \\Bio\\B    |                                             |\n\n## 匹配次数及组合匹配\n\n| 符号           | 解释                           | 示例             | 说明                                                         |\n| -------------- | ------------------------------ | ---------------- | ------------------------------------------------------------ |\n| []             | 匹配来自字符集的任意单一字符   | [aeiou]          | 可以匹配任一元音字母字符                                     |\n| [^]            | 匹配不在字符集中的任意单一字符 | [^aeiou]         | 可以匹配任一非元音字母字符                                   |\n| *              | 匹配0次或多次                  | \\w*              |                                                              |\n| +              | 匹配1次或多次                  | \\w+              |                                                              |\n| ?              | 匹配0次或1次                   | \\w?              |                                                              |\n| {N}            | 匹配N次                        | \\w{3}            |                                                              |\n| {M,}           | 匹配至少M次                    | \\w{3,}           |                                                              |\n| {M,N}          | 匹配至少M次至多N次             | \\w{3,6}          |                                                              |\n| (?#)           | 注释                           |                  |                                                              |\n| (exp)          | 匹配exp并捕获到自动命名的组中  |                  |                                                              |\n| (? \\<name>exp) | 匹配exp并捕获到名为name的组中  |                  |                                                              |\n| (?:exp)        | 匹配exp但是不捕获匹配的文本    |                  |                                                              |\n| (?=exp)        | 匹配exp前面的位置              | \\b\\w+(?=ing)     | 可以匹配I\'m dancing中的danc                                  |\n| (?<=exp)       | 匹配exp后面的位置              | (?<=\\bdanc)\\w+\\b | 可以匹配I love dancing and reading中的第一个ing              |\n| (?!exp)        | 匹配后面不是exp的位置          |                  |                                                              |\n| (?<!exp)       | 匹配前面不是exp的位置          |                  |                                                              |\n| *?             | 重复任意次，但尽可能少重复     | a.\\*b a.\\*?b     | 将正则表达式应用于aabab，前者会匹配整个字符串aabab，后者会匹配aab和ab两个字符串 |\n| +?             | 重复1次或多次，但尽可能少重复  |                  |                                                              |\n| ??             | 重复0次或1次，但尽可能少重复   |                  |                                                              |\n| {M,N}?         | 重复M到N次，但尽可能少重复     |                  |                                                              |\n| {M,}?          | 重复M次以上，但尽可能少重复    |                  |                                                              |\n\n> 说明： 如果需要匹配的字符是正则表达式中的特殊字符，那么可以使用\\进行转义处理，例如想匹配小数点可以写成\\\\.就可以了，因为直接写.会匹配任意字符；同理，想匹配圆括号必须写成\\\\(和\\\\)，否则圆括号被视为正则表达式中的分组。\n\n# Python对正则表达式的支持\n\n> Python提供了re模块来支持正则表达式相关操作，下面是re模块中的核心函数。\n\n## re模块中的核心函数\n\n| 函数                                           | 说明                                                         |\n| ---------------------------------------------- | ------------------------------------------------------------ |\n| complie(pattern, flags=0)                      | 编译正则表达式返回正则表达式对象                             |\n| match(pattern, string, flags=0)                | 用正则表达式匹配字符串 成功返回匹配对象 否则返回None         |\n| search(pattern, string, flags=0)               | 搜索字符串中第一次出现正则表达式的模式 成功返回匹配对象 否则返回None |\n| split(pattern, repl, string, count=0, flags=0) | 用正则表达式指定的模式分隔符拆分字符串 返回列表              |\n| sub(pattern, repl, string, count=0, flags=0)   | 用指定的字符串替换原字符串中与正则表达式匹配的模式 可以用count指定替换的次数 |\n| fullmatch(pattern, string, flags=0)            | match函数的完全匹配（从字符串开头到结尾）版本                |\n| findall(pattern, string, flags=0)              | 查找字符串所有与正则表达式匹配的模式 返回字符串的列表        |\n| finditer(pattern, string, flags=0)             | 查找字符串所有与正则表达式匹配的模式 返回一个迭代器          |\n| purge()                                        | 清除隐式编译的正则表达式的缓存                               |\n| re.I / re.IGNORECASE                           | 忽略大小写匹配标记                                           |\n| re.M / re.MULTILINE                            | 多行匹配标记                                                 |\n\n> **说明：** 上面提到的re模块中的这些函数，实际开发中也可以用正则表达式对象的方法替代对这些函数的使用，如果一个正则表达式需要重复的使用，那么先通过compile函数编译正则表达式并创建出正则表达式对象无疑是更为明智的选择。', '<blockquote>\n<p>本篇主要介绍Python正则表达式的re库的基本使用方法。</p>\n<p>本篇主要内容的整理来自于：</p>\n<p><a href=\"https://docs.python.org/zh-cn/3/library/re.html\">Python-re库的官方文档</a></p>\n<p><a href=\"[https://github.com/jackfrued/Python-100-Days/blob/master/Day01-15/12.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.md](https://github.com/jackfrued/Python-100-Days/blob/master/Day01-15/12.字符串和正则表达式.md\">Python-0-100天正则表达式部分</a>)</p>\n<p><a href=\"https://deerchao.net/tutorials/regex/regex.htm\">正则表达式30分钟入门</a></p>\n</blockquote>\n<h1 id=\"h1-u4EC0u4E48u662Fu6B63u5219u8868u8FBEu5F0F\"><a name=\"什么是正则表达式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是正则表达式</h1><p>在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。<strong>正则表达式</strong>就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。</p>\n<p>换句话说正则表达式是一种工具，它定义了字符串的匹配模式（如何检查一个字符串是否有跟某种模式匹配的部分或者从一个字符串中将与模式匹配的部分提取出来或者替换掉）。如果你在Windows操作系统中使用过文件查找并且在指定文件名时使用过通配符（*和?），那么正则表达式也是与之类似的用来进行文本匹配的工具，只不过比起通配符正则表达式更强大，它能更精确地描述你的需求（当然你付出的代价是书写一个正则表达式比打出一个通配符要复杂得多，要知道任何给你带来好处的东西都是有代价的，就如同学习一门编程语言一样），比如你可以编写一个正则表达式，用来查找所有以0开头，后面跟着2-3个数字，然后是一个连字号“-”，最后是7或8位数字的字符串（像028-12345678或0813-7654321），这不就是国内的座机号码吗。最初计算机是为了做数学运算而诞生的，处理的信息基本上都是数值，而今天我们在日常工作中处理的信息基本上都是文本数据，我们希望计算机能够识别和处理符合某些模式的文本，正则表达式就显得非常重要了。今天几乎所有的编程语言都提供了对正则表达式操作的支持，Python通过标准库中的re模块来支持正则表达式操作。</p>\n<p>我们可以考虑下面一个问题：我们从某个地方（可能是一个文本文件，也可能是网络上的一则新闻）获得了一个字符串，希望在字符串中找出手机号和座机号。当然我们可以设定手机号是11位的数字（注意并不是随机的11位数字，因为你没有见过“25012345678”这样的手机号吧）而座机号跟上一段中描述的模式相同，如果不使用正则表达式要完成这个任务就会很麻烦。</p>\n<h1 id=\"h1-u6B63u5219u8868u8FBEu5F0Fu4E2Du7684u57FAu672Cu7B26u53F7u627Cu8981u603Bu7ED3\"><a name=\"正则表达式中的基本符号扼要总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>正则表达式中的基本符号扼要总结</h1><h2 id=\"h2-u5339u914Du7C7Bu578B\"><a name=\"匹配类型\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>匹配类型</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">符号</th>\n<th style=\"text-align:left\">解释</th>\n<th style=\"text-align:left\">示例</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">.</td>\n<td style=\"text-align:left\">匹配任意字符</td>\n<td style=\"text-align:left\">b.t</td>\n<td style=\"text-align:left\">可以匹配bat/but/b#t/b2t等</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\w</td>\n<td style=\"text-align:left\">匹配字母/数字/下划线</td>\n<td style=\"text-align:left\">b\\wt</td>\n<td style=\"text-align:left\">可以匹配bat/but/b_t等 但是不能匹配b#t</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\s</td>\n<td style=\"text-align:left\">匹配空白字符(包括\\t、\\n、\\r)</td>\n<td style=\"text-align:left\">love\\syou</td>\n<td style=\"text-align:left\">可以匹配love you</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\d</td>\n<td style=\"text-align:left\">匹配数字</td>\n<td style=\"text-align:left\">\\d\\d</td>\n<td style=\"text-align:left\">可以匹配01/99/34/54等</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\b</td>\n<td style=\"text-align:left\">匹配单词的边界</td>\n<td style=\"text-align:left\">\\bThe\\b</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">^</td>\n<td style=\"text-align:left\">匹配字符串的开始</td>\n<td style=\"text-align:left\">^The</td>\n<td style=\"text-align:left\">可以匹配The开头的字符串</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$</td>\n<td style=\"text-align:left\">匹配字符串的结束</td>\n<td style=\"text-align:left\">$.exe</td>\n<td style=\"text-align:left\">可以匹配.exe结束的字符串</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\W</td>\n<td style=\"text-align:left\">匹配非(字母/数字/下划线)</td>\n<td style=\"text-align:left\">b\\Wt</td>\n<td style=\"text-align:left\">可以匹配b<a href=\"https://github.com/t\" title=\"&#64;t\" class=\"at-link\">@t</a>/b#t等 但是不能匹配b1t/but/b_t等</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\S</td>\n<td style=\"text-align:left\">匹配非空白字符</td>\n<td style=\"text-align:left\">love\\Syou</td>\n<td style=\"text-align:left\">可以匹配love#you等 但是不能匹配love you</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\D</td>\n<td style=\"text-align:left\">匹配非数字</td>\n<td style=\"text-align:left\">\\d\\D</td>\n<td style=\"text-align:left\">可以匹配3#/5f/6^等</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\B</td>\n<td style=\"text-align:left\">匹配非单词边界</td>\n<td style=\"text-align:left\">\\Bio\\B</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"h2-u5339u914Du6B21u6570u53CAu7EC4u5408u5339u914D\"><a name=\"匹配次数及组合匹配\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>匹配次数及组合匹配</h2><table>\n<thead>\n<tr>\n<th>符号</th>\n<th>解释</th>\n<th>示例</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>[]</td>\n<td>匹配来自字符集的任意单一字符</td>\n<td>[aeiou]</td>\n<td>可以匹配任一元音字母字符</td>\n</tr>\n<tr>\n<td>[^]</td>\n<td>匹配不在字符集中的任意单一字符</td>\n<td>[^aeiou]</td>\n<td>可以匹配任一非元音字母字符</td>\n</tr>\n<tr>\n<td>*</td>\n<td>匹配0次或多次</td>\n<td>\\w*</td>\n<td></td>\n</tr>\n<tr>\n<td>+</td>\n<td>匹配1次或多次</td>\n<td>\\w+</td>\n<td></td>\n</tr>\n<tr>\n<td>?</td>\n<td>匹配0次或1次</td>\n<td>\\w?</td>\n<td></td>\n</tr>\n<tr>\n<td>{N}</td>\n<td>匹配N次</td>\n<td>\\w{3}</td>\n<td></td>\n</tr>\n<tr>\n<td>{M,}</td>\n<td>匹配至少M次</td>\n<td>\\w{3,}</td>\n<td></td>\n</tr>\n<tr>\n<td>{M,N}</td>\n<td>匹配至少M次至多N次</td>\n<td>\\w{3,6}</td>\n<td></td>\n</tr>\n<tr>\n<td>(?#)</td>\n<td>注释</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>(exp)</td>\n<td>匹配exp并捕获到自动命名的组中</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>(? \\&lt;name&gt;exp)</td>\n<td>匹配exp并捕获到名为name的组中</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>(?:exp)</td>\n<td>匹配exp但是不捕获匹配的文本</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>(?=exp)</td>\n<td>匹配exp前面的位置</td>\n<td>\\b\\w+(?=ing)</td>\n<td>可以匹配I’m dancing中的danc</td>\n</tr>\n<tr>\n<td>(?&lt;=exp)</td>\n<td>匹配exp后面的位置</td>\n<td>(?&lt;=\\bdanc)\\w+\\b</td>\n<td>可以匹配I love dancing and reading中的第一个ing</td>\n</tr>\n<tr>\n<td>(?!exp)</td>\n<td>匹配后面不是exp的位置</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>(?&lt;!exp)</td>\n<td>匹配前面不是exp的位置</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>*?</td>\n<td>重复任意次，但尽可能少重复</td>\n<td>a.*b a.*?b</td>\n<td>将正则表达式应用于aabab，前者会匹配整个字符串aabab，后者会匹配aab和ab两个字符串</td>\n</tr>\n<tr>\n<td>+?</td>\n<td>重复1次或多次，但尽可能少重复</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>??</td>\n<td>重复0次或1次，但尽可能少重复</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>{M,N}?</td>\n<td>重复M到N次，但尽可能少重复</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>{M,}?</td>\n<td>重复M次以上，但尽可能少重复</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>说明： 如果需要匹配的字符是正则表达式中的特殊字符，那么可以使用\\进行转义处理，例如想匹配小数点可以写成\\.就可以了，因为直接写.会匹配任意字符；同理，想匹配圆括号必须写成\\(和\\)，否则圆括号被视为正则表达式中的分组。</p>\n</blockquote>\n<h1 id=\"h1-python-\"><a name=\"Python对正则表达式的支持\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Python对正则表达式的支持</h1><blockquote>\n<p>Python提供了re模块来支持正则表达式相关操作，下面是re模块中的核心函数。</p>\n</blockquote>\n<h2 id=\"h2-re-\"><a name=\"re模块中的核心函数\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>re模块中的核心函数</h2><table>\n<thead>\n<tr>\n<th>函数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>complie(pattern, flags=0)</td>\n<td>编译正则表达式返回正则表达式对象</td>\n</tr>\n<tr>\n<td>match(pattern, string, flags=0)</td>\n<td>用正则表达式匹配字符串 成功返回匹配对象 否则返回None</td>\n</tr>\n<tr>\n<td>search(pattern, string, flags=0)</td>\n<td>搜索字符串中第一次出现正则表达式的模式 成功返回匹配对象 否则返回None</td>\n</tr>\n<tr>\n<td>split(pattern, repl, string, count=0, flags=0)</td>\n<td>用正则表达式指定的模式分隔符拆分字符串 返回列表</td>\n</tr>\n<tr>\n<td>sub(pattern, repl, string, count=0, flags=0)</td>\n<td>用指定的字符串替换原字符串中与正则表达式匹配的模式 可以用count指定替换的次数</td>\n</tr>\n<tr>\n<td>fullmatch(pattern, string, flags=0)</td>\n<td>match函数的完全匹配（从字符串开头到结尾）版本</td>\n</tr>\n<tr>\n<td>findall(pattern, string, flags=0)</td>\n<td>查找字符串所有与正则表达式匹配的模式 返回字符串的列表</td>\n</tr>\n<tr>\n<td>finditer(pattern, string, flags=0)</td>\n<td>查找字符串所有与正则表达式匹配的模式 返回一个迭代器</td>\n</tr>\n<tr>\n<td>purge()</td>\n<td>清除隐式编译的正则表达式的缓存</td>\n</tr>\n<tr>\n<td>re.I / re.IGNORECASE</td>\n<td>忽略大小写匹配标记</td>\n</tr>\n<tr>\n<td>re.M / re.MULTILINE</td>\n<td>多行匹配标记</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p><strong>说明：</strong> 上面提到的re模块中的这些函数，实际开发中也可以用正则表达式对象的方法替代对这些函数的使用，如果一个正则表达式需要重复的使用，那么先通过compile函数编译正则表达式并创建出正则表达式对象无疑是更为明智的选择。</p>\n</blockquote>\n', '2020-07-13', '2020-07-13', '0');
INSERT INTO `article_info` VALUES ('72', 'Simhash的改进', '56', '> Simhash来自于Google Moses Charikar发表的一篇论文 “detecting near-duplicates for web crawling” 中提出了simhash算法，专门用来解决海量数据的去重任务。这个算法通过将一个文档转化为一个64位的二进制特征串，然后比较两个文档的特征串，如果这两个文档的特征串的海明距离小于某个值（一般来讲这个值为3），则说明这是相似文档。\n\n> 7月20日修改\n\n## Simhash原理\n\nSimhash算法是局部敏感哈希的一种，其主要思想是将高维特征向量降维成低维的特征向量，通过比较两个向量的Hamming Distance来确定文章的相似度。所以Simhash算法就是通过比较两个Hamming Distance，以获取相似度，如果这个相似度小于某个规定的值，就说明这两个文本相似。\n\n![](https://i.loli.net/2019/07/24/5d383f29a715a95102.jpg)\n\n<center/>Simhash原理图\n\n对于文本信息，我们需要对其作如下处理：\n\n1. 文本分词\n\n   首先我们需要对文本进行分词处理，也就是将文本的所包含的关键词提取出来，这部分我们可以使用目前常见的中文分词库来进行处理。这样我们就得到了一些关键词。\n\n2. 给关键词赋权\n\n   第二步需要根据权重给不同的关键词赋予权值。关于关键词的权重目前有很多种不同的计算方式，简单一些的比如根据关键词在文中出现的次数赋予权值，比较复杂但是更能体现实际意义的比如：TD-IDF算法、TextRank算法等等。目前所见的比较流行的分词工具都带有计算关键词权重的方法，所以在我们这个简单的实现中，这一步就用分词工具进行处理。这样我们获得了关键词以及其对应的权重。\n\n3. 对每个关键词进行hash运算\n\n   第三步我们对每个关键词进行hash运算，通常我们使用64位hash。这里我们为了方便用8位hash举例。    比如：\n\n   假设 “上海” 的hash值为：01011001\n\n   假设 “北京” 的hash值为：11001011\n\n   ......\n\n   这样我们对每个关键词都得到了它们各自的hash。\n\n4. 对hash值加权处理\n\n   第四步加权处理所遵循的原则就是：如果某位是0，这位就变成 -Weight，反之这位就变成 Weight。\n\n   比如：\n\n   “上海” 的权值为：45.11\n\n   那么“上海”的特征向量就变为：-45.11 45.11 -45.11 45.11 45.11 -45.11 -45.11 45.11\n\n   “北京” 的权值为：32.09\n\n   那么“北京”的特征向量就变为：32.09 32.09 -32.09 -32.09 32.09 -32.09 32.09 32.09\n\n   ......\n\n5. 对所用关键词的权值进行求和\n\n   第五步就是对所有关键字的特征向量的每一位的值分别求和，比如：\n\n   以两个关键词为例（“上海”、“北京”）：-13.02 77.20 -77.20 13.02 77.20 -77.20 -13.02 77.20\n\n6. 转化为二进制\n\n   第六步，将最后的求和结果大于零位记录为1，小于零的记录为0，以上述为例：01011001\n\n   01011001就是这个文本的特征hash\n\n7. 计算hamming distance\n\n   我们假设两个文本的特征hash分别为：\n\n   00101110\n\n   00001111\n\n   它们的海明距离为2，我们就可以说这两个文章是相似的。\n\n---\n\n## Golang代码实现\n\n> 使用了一个Github的开源项目，里面的simhash是32位的，我们只是将其改成64位，只改动了一小点地方。\n\n本次代码实现我们使用了几个开源项目：\n\n[NETkiddy/**simhash_similarity**](<https://github.com/NETkiddy/simhash_similarity>)\n\n[yanyiwu/**gojieba**](<https://github.com/yanyiwu/gojieba>)\n\n第一个为golang实现的simhash的项目，一个为jieba分词库的golang版本。下面是代码：\n\n```go\npackage main\n\nimport (\n	\"fmt\"\n	\"hash/fnv\"\n	\"simhash_similarity_jieba\"\n	\"strings\"\n)\n\ntype WordWeight struct {\n	Word   string\n	Weight float64\n}\n\nfunc main() {\n\n	g := simhash.NewGoJieba()\n\n	srcStr := \"已成为当前信息领域的一个新的研究热点 . 共识算法是区块链系统的关键要素之一 , 本文对目前已经提出的 32 种主流区块链共识算法进行了系统性的梳理与分析 . 需要说明的是 , 由于近年来共识算法研究发展较快 , 本文讨论的识算法可能仅为实际共识算法的一个子集 , 尚存在若干新兴或者小众的共识算法未加以讨论 , 同时一些较新的共识算法仍在不断试错和优化阶段 . 本文工作可望为后续的研究与应用提供有益的启发与借鉴 .以目前的研究现状而言区块链共识算法的未来研究趋势将主要侧重于区块链共识算法性评估、共识算法 – 激励机制的适配优化以及新型区块链结构下的共识创新三个方面 .首先 , 区块链共识算法在经历过一段百花齐放式的探索和创新之后 , 势必会趋向于收敛到新共识算法的性能评估和标准化方面的研究 . 目前 , 共识算法的评价指标各异 , 但一般均侧重于社会学角度的公平性和去中心化程度 , 经济学角度的能耗、成本与参与者的激励相容性以及计算机科学角度的可扩展性 ( 交易吞吐量、节点可扩展等 ) 、容错性和安全性等 . 如何结合具体需求和应用场景 自适应地实现针对特定性能评价目标的共识机制设计与算法优化 , 将是未来研究的热点之一 .其次 , 区块链的共识算法与激励机制是紧密耦合、不可分割的整体 , 同时二者互有侧重点 : 共识算法规定了矿工为维护区块链账本安全性、一致性和活性而必须遵守的行为规范和行动次序 ; 激励机制则规定了在共识过程中为鼓励矿工忠实、高效地验证区块链账本数据而发行的经济权益 , 通常包括代币发行机制、代币分配机制、交易费定价机制 [53] 等 .从研究角度来看 , 如果将区块链系统运作过程建模为矿工和矿池的大群体博弈过程 [54] 的话 , 那么共识算法将决定其博弈树的结构和形状、激励机制将决定矿工和矿池在博弈树中每个叶子结点的收益 . 因此 , 区块链共识算法和激励机制不仅各自存在独立优化的必要性 , 更为重要地是共识 – 激励二元耦合机制的联合优化、实现共识与激励的 “ 适配 ”, 这是解决区块链系统中不断涌现出的扣块攻击、自私挖矿等策略性行为、保障区块链系统健康稳定运行的关键问题 , 迫切需要未来研究的跟进 .最后 , 随着区块链技术的发展、特别是数据层的技术和底层拓扑结构的不断创新 , 目前已经涌现出若干新兴的区块 “ 链 ” 数据结构 , 例如有向无环图(Directed acyclic graph) 和哈希图 (HashGraph)等 . 这些新数据结构将以单一链条为基础的区块链技术的范畴展为基于图结构的区块 “ 链 ” 或分布式账本 . 例如适用于物联网支付场景的数字货币OTA 即采用称为 “Tangle ( 缠结 )” 的 DAG 拓扑结构 , 其共识过程以交易 ( 而非区块 ) 为粒度 , 每个交易都引证其他两个交易的合法性、形成 DAG 网络 ,因而可以实现无区块 (Blockless) 共识 ; HashGraph共识则更进一步 , 基于 Gossip of gossip 协议和虚拟投票等技术 , 以交易为粒度 , 在特定的 DAG 结构上2020自动实现公平和快速的拜占庭容错共识 . 这些新型区块\"\n	dstStr := \"那么共识算法将决定其博弈树的结构和形状、激励机制将决定矿工和矿池在博弈树中每个叶子结点的收益 . 因此 , 区块链共识算法和激励机制不仅各自存在独立优化的必要性 , 更为重要地是共识 – 激励二元耦合机制的联合优化、实现共识与激励的 “ 适配 ”, 这是解决区块链系统中不断涌现出的扣块攻击、自私挖矿等策略性行为、保障区块链系统健康稳定运行的关键问题 , 迫切需要未来研究的跟进 .最后 , 随着区块链技术的发展、特别是数据层的技术和底层拓扑结构的不断创新 , 目前已经涌现出若干新兴的区块 “ 链 ” 数据结构 , 例如有向无环图(Directed acyclic graph) 和哈希图 (HashGraph)等 . 这些新数据结构将以单一链条为基础的区块链技术的范畴展为基于图结构的区块 “ 链 ” 或分布式账本 . 例如适用于物联网支付场景的数字货币OTA 即采用称为 “Tangle ( 缠结 )” 的 DAG 拓扑结构 , 其共识过程以交易 ( 而非区块 ) 为粒度 , 每个交易都引证其他两个交易的合法性、形成 DAG 网络 ,因而可以实现无区块 (Blockless) 共识 ; HashGraph共识则更进一步 , 基于 Gossip of gossip 协议和虚拟投票等技术 , 以交易为粒度 , 在特定的 DAG 结构上2020自动实现公平和快速的拜占庭容错共识 . 这些新型区块拓扑结构及其共识算法是未来发展趋势之一 , 建立在这些新型数据结构之上的共识算法也值得深入研究\"\n    // 第二个参数为分出关键词的个数\n	srcWordsWeight := g.C.ExtractWithWeight(srcStr, 22)\n	dstWordsWeight := g.C.ExtractWithWeight(dstStr, 11)\n	//fmt.Printf(\"srcWordsWeight: %v\\n\", srcWordsWeight)\n	//fmt.Printf(\"dstWordsWeight: %v\\n\", dstWordsWeight)\n\n	srcWords := make([]WordWeight, len(srcWordsWeight))\n	dstWords := make([]WordWeight, len(dstWordsWeight))\n	for i, ww := range srcWordsWeight {\n		word := WordWeight{Word: ww.Word, Weight: ww.Weight}\n		srcWords[i] = word\n	}\n	for i, ww := range dstWordsWeight {\n		word := WordWeight{Word: ww.Word, Weight: ww.Weight}\n		dstWords[i] = word\n	}\n	fmt.Printf(\"srcWords&weight:%v\\n\", srcWords)\n	fmt.Printf(\"dstWords&weight:%v\\n\", dstWords)\n\n	distance, err := SimHashSimilar64(srcWords, dstWords)\n	if err != nil {\n		fmt.Printf(\"failed: %v\", err)\n	}\n\n	fmt.Printf(\"SimHashSimilar distance: %v\", distance)\n}\n\n\n\n\n// 传入两个WordWeight类型的列表返回相似度值\nfunc SimHashSimilar64(srcWordWeighs, dstWordWeights []WordWeight) (distance int, err error) {\n\n	srcFingerPrint, err := simhashFingerPrint64(srcWordWeighs)\n	if err != nil {\n		return\n	}\n	fmt.Println(\"srcFingerPrint: \", srcFingerPrint)\n	dstFingerPrint, err := simhashFingerPrint64(dstWordWeights)\n	if err != nil {\n		return\n	}\n	fmt.Println(\"dstFingerPrint: \", dstFingerPrint)\n\n	distance = hammingDistance(srcFingerPrint, dstFingerPrint)\n\n	return\n}\n\n// rewrite simhashFingerPrint\n// 使用64位hash指纹进行运算\n\nfunc simhashFingerPrint64(wordWeights []WordWeight) (fingerPrint []string, err error) {\n	// 使用64位创建64个元素的二进制权重\n	binaryWeights := make([]float64, 64)\n	for _, ww := range wordWeights {\n		bitHash := strHashBitCode64(ww.Word)\n		weights := calcWithWeight64(bitHash, ww.Weight) //binary每个元素与weight的乘积结果数组\n		binaryWeights, err = sliceInnerPlus64(binaryWeights, weights)	//对每个hash数组求和\n		//fmt.Printf(\"ww.Word:%v, bitHash:%v, ww.Weight:%v, binaryWeights: %v\\n\", ww.Word,bitHash, ww.Weight, binaryWeights)\n		if err != nil {\n			return\n		}\n	}\n	fingerPrint = make([]string, 0)\n	// 将求和后的数组重新根据正负转化为2进制hash数组\n	for _, b := range binaryWeights {\n		if b > 0 { // bit 1\n			fingerPrint = append(fingerPrint, \"1\")\n		} else { // bit 0\n			fingerPrint = append(fingerPrint, \"0\")\n		}\n	}\n	return\n}\n\n// rewrite strHashBitCoin 64bit\n// 返回一个64位的二进制字符串,也就是对这个关键字进行hash运算之后的hash字符串\nfunc strHashBitCode64(str string) string {\n	h := fnv.New64a()\n	h.Write([]byte(str))\n	b := int64(h.Sum64())\n	return fmt.Sprintf(\"%064b\", b)\n}\n\n// binary每个元素与weight的乘积结果数组,重写为64位操作\n// 就是hash完关键字的64位二进制串上都变成 [ weight, -weight, -weight, ... ,weight]的形式\nfunc calcWithWeight64(bitHash string, weight float64) []float64 {\n	// 首先分割字符串\n	bitHashs := strings.Split(bitHash, \"\")\n	// 构造一个长度为0的slice,之后往里添加元素\n	binarys := make([]float64, 0)\n\n	for _, bit := range bitHashs {\n		if bit == \"0\" {\n			// 根据simhash算法,如果这位上为0就乘以负的权值\n			binarys = append(binarys, float64(-1)*weight)\n		} else {\n			// 反正,这位为1就乘以正权值\n			binarys = append(binarys, float64(weight))\n		}\n	}\n	return binarys\n}\n\n// 对其每个求完权值并且进行完向量运算的64位hash特征串进行求和运算\n// 假设arr2为第n个关键字,那么arr1就是前n-1个关键字每一位带权hash的和\nfunc sliceInnerPlus64(arr1, arr2 [] float64) (dstArr []float64, err error) {\n\n	dstArr = make([]float64, len(arr1), len(arr1))\n\n	if arr1 == nil || arr2 == nil {\n		err = fmt.Errorf(\"sliceInnerPlus array nil\")\n		return\n	}\n	if len(arr1) != len(arr2) {\n		err = fmt.Errorf(\"sliceInnerPlus array Length NOT match, %v != %v\", len(arr1), len(arr2))\n		return\n	}\n\n	for i, v1 := range arr1 {\n		dstArr[i] = v1 + arr2[i]\n	}\n\n	return\n}\n\nfunc hammingDistance(arr1, arr2 []string) int {\n	count := 0\n	for i, v1 := range arr1 {\n		if v1 != arr2[i] {\n			count++\n		}\n	}\n\n	return count\n}\n```\n\n具体函数细节请移步GitHub源码~\n\n> 参考：\n>\n> <http://yanyiwu.com/work/2014/01/30/simhash-shi-xian-xiang-jie.html>\n>\n> <https://wizardforcel.gitbooks.io/the-art-of-programming-by-july/content/06.03.html>\n>\n> 关于更多的中文分词信息可以[点击这里](<https://www.zhihu.com/question/19578687>)\n>\n> 关于Hamming Distance点击 -> [海明距离](https://baike.baidu.com/item/海明距离)', '<blockquote>\n<p>Simhash来自于Google Moses Charikar发表的一篇论文 “detecting near-duplicates for web crawling” 中提出了simhash算法，专门用来解决海量数据的去重任务。这个算法通过将一个文档转化为一个64位的二进制特征串，然后比较两个文档的特征串，如果这两个文档的特征串的海明距离小于某个值（一般来讲这个值为3），则说明这是相似文档。</p>\n<p>7月20日修改</p>\n</blockquote>\n<h2 id=\"h2-simhash-\"><a name=\"Simhash原理\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Simhash原理</h2><p>Simhash算法是局部敏感哈希的一种，其主要思想是将高维特征向量降维成低维的特征向量，通过比较两个向量的Hamming Distance来确定文章的相似度。所以Simhash算法就是通过比较两个Hamming Distance，以获取相似度，如果这个相似度小于某个规定的值，就说明这两个文本相似。</p>\n<p><img src=\"https://i.loli.net/2019/07/24/5d383f29a715a95102.jpg\" alt=\"\"></p>\n<p>&lt;center/&gt;Simhash原理图</p>\n<p>对于文本信息，我们需要对其作如下处理：</p>\n<ol>\n<li><p>文本分词</p>\n<p>首先我们需要对文本进行分词处理，也就是将文本的所包含的关键词提取出来，这部分我们可以使用目前常见的中文分词库来进行处理。这样我们就得到了一些关键词。</p>\n</li><li><p>给关键词赋权</p>\n<p>第二步需要根据权重给不同的关键词赋予权值。关于关键词的权重目前有很多种不同的计算方式，简单一些的比如根据关键词在文中出现的次数赋予权值，比较复杂但是更能体现实际意义的比如：TD-IDF算法、TextRank算法等等。目前所见的比较流行的分词工具都带有计算关键词权重的方法，所以在我们这个简单的实现中，这一步就用分词工具进行处理。这样我们获得了关键词以及其对应的权重。</p>\n</li><li><p>对每个关键词进行hash运算</p>\n<p>第三步我们对每个关键词进行hash运算，通常我们使用64位hash。这里我们为了方便用8位hash举例。    比如：</p>\n<p>假设 “上海” 的hash值为：01011001</p>\n<p>假设 “北京” 的hash值为：11001011</p>\n<p>……</p>\n<p>这样我们对每个关键词都得到了它们各自的hash。</p>\n</li><li><p>对hash值加权处理</p>\n<p>第四步加权处理所遵循的原则就是：如果某位是0，这位就变成 -Weight，反之这位就变成 Weight。</p>\n<p>比如：</p>\n<p>“上海” 的权值为：45.11</p>\n<p>那么“上海”的特征向量就变为：-45.11 45.11 -45.11 45.11 45.11 -45.11 -45.11 45.11</p>\n<p>“北京” 的权值为：32.09</p>\n<p>那么“北京”的特征向量就变为：32.09 32.09 -32.09 -32.09 32.09 -32.09 32.09 32.09</p>\n<p>……</p>\n</li><li><p>对所用关键词的权值进行求和</p>\n<p>第五步就是对所有关键字的特征向量的每一位的值分别求和，比如：</p>\n<p>以两个关键词为例（“上海”、“北京”）：-13.02 77.20 -77.20 13.02 77.20 -77.20 -13.02 77.20</p>\n</li><li><p>转化为二进制</p>\n<p>第六步，将最后的求和结果大于零位记录为1，小于零的记录为0，以上述为例：01011001</p>\n<p>01011001就是这个文本的特征hash</p>\n</li><li><p>计算hamming distance</p>\n<p>我们假设两个文本的特征hash分别为：</p>\n<p>00101110</p>\n<p>00001111</p>\n<p>它们的海明距离为2，我们就可以说这两个文章是相似的。</p>\n</li></ol>\n<hr>\n<h2 id=\"h2-golang-\"><a name=\"Golang代码实现\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Golang代码实现</h2><blockquote>\n<p>使用了一个Github的开源项目，里面的simhash是32位的，我们只是将其改成64位，只改动了一小点地方。</p>\n</blockquote>\n<p>本次代码实现我们使用了几个开源项目：</p>\n<p><a href=\"https://github.com/NETkiddy/simhash_similarity\">NETkiddy/<strong>simhash_similarity</strong></a></p>\n<p><a href=\"https://github.com/yanyiwu/gojieba\">yanyiwu/<strong>gojieba</strong></a></p>\n<p>第一个为golang实现的simhash的项目，一个为jieba分词库的golang版本。下面是代码：</p>\n<pre><code class=\"lang-go\">package main\n\nimport (\n    &quot;fmt&quot;\n    &quot;hash/fnv&quot;\n    &quot;simhash_similarity_jieba&quot;\n    &quot;strings&quot;\n)\n\ntype WordWeight struct {\n    Word   string\n    Weight float64\n}\n\nfunc main() {\n\n    g := simhash.NewGoJieba()\n\n    srcStr := &quot;已成为当前信息领域的一个新的研究热点 . 共识算法是区块链系统的关键要素之一 , 本文对目前已经提出的 32 种主流区块链共识算法进行了系统性的梳理与分析 . 需要说明的是 , 由于近年来共识算法研究发展较快 , 本文讨论的识算法可能仅为实际共识算法的一个子集 , 尚存在若干新兴或者小众的共识算法未加以讨论 , 同时一些较新的共识算法仍在不断试错和优化阶段 . 本文工作可望为后续的研究与应用提供有益的启发与借鉴 .以目前的研究现状而言区块链共识算法的未来研究趋势将主要侧重于区块链共识算法性评估、共识算法 – 激励机制的适配优化以及新型区块链结构下的共识创新三个方面 .首先 , 区块链共识算法在经历过一段百花齐放式的探索和创新之后 , 势必会趋向于收敛到新共识算法的性能评估和标准化方面的研究 . 目前 , 共识算法的评价指标各异 , 但一般均侧重于社会学角度的公平性和去中心化程度 , 经济学角度的能耗、成本与参与者的激励相容性以及计算机科学角度的可扩展性 ( 交易吞吐量、节点可扩展等 ) 、容错性和安全性等 . 如何结合具体需求和应用场景 自适应地实现针对特定性能评价目标的共识机制设计与算法优化 , 将是未来研究的热点之一 .其次 , 区块链的共识算法与激励机制是紧密耦合、不可分割的整体 , 同时二者互有侧重点 : 共识算法规定了矿工为维护区块链账本安全性、一致性和活性而必须遵守的行为规范和行动次序 ; 激励机制则规定了在共识过程中为鼓励矿工忠实、高效地验证区块链账本数据而发行的经济权益 , 通常包括代币发行机制、代币分配机制、交易费定价机制 [53] 等 .从研究角度来看 , 如果将区块链系统运作过程建模为矿工和矿池的大群体博弈过程 [54] 的话 , 那么共识算法将决定其博弈树的结构和形状、激励机制将决定矿工和矿池在博弈树中每个叶子结点的收益 . 因此 , 区块链共识算法和激励机制不仅各自存在独立优化的必要性 , 更为重要地是共识 – 激励二元耦合机制的联合优化、实现共识与激励的 “ 适配 ”, 这是解决区块链系统中不断涌现出的扣块攻击、自私挖矿等策略性行为、保障区块链系统健康稳定运行的关键问题 , 迫切需要未来研究的跟进 .最后 , 随着区块链技术的发展、特别是数据层的技术和底层拓扑结构的不断创新 , 目前已经涌现出若干新兴的区块 “ 链 ” 数据结构 , 例如有向无环图(Directed acyclic graph) 和哈希图 (HashGraph)等 . 这些新数据结构将以单一链条为基础的区块链技术的范畴展为基于图结构的区块 “ 链 ” 或分布式账本 . 例如适用于物联网支付场景的数字货币OTA 即采用称为 “Tangle ( 缠结 )” 的 DAG 拓扑结构 , 其共识过程以交易 ( 而非区块 ) 为粒度 , 每个交易都引证其他两个交易的合法性、形成 DAG 网络 ,因而可以实现无区块 (Blockless) 共识 ; HashGraph共识则更进一步 , 基于 Gossip of gossip 协议和虚拟投票等技术 , 以交易为粒度 , 在特定的 DAG 结构上2020自动实现公平和快速的拜占庭容错共识 . 这些新型区块&quot;\n    dstStr := &quot;那么共识算法将决定其博弈树的结构和形状、激励机制将决定矿工和矿池在博弈树中每个叶子结点的收益 . 因此 , 区块链共识算法和激励机制不仅各自存在独立优化的必要性 , 更为重要地是共识 – 激励二元耦合机制的联合优化、实现共识与激励的 “ 适配 ”, 这是解决区块链系统中不断涌现出的扣块攻击、自私挖矿等策略性行为、保障区块链系统健康稳定运行的关键问题 , 迫切需要未来研究的跟进 .最后 , 随着区块链技术的发展、特别是数据层的技术和底层拓扑结构的不断创新 , 目前已经涌现出若干新兴的区块 “ 链 ” 数据结构 , 例如有向无环图(Directed acyclic graph) 和哈希图 (HashGraph)等 . 这些新数据结构将以单一链条为基础的区块链技术的范畴展为基于图结构的区块 “ 链 ” 或分布式账本 . 例如适用于物联网支付场景的数字货币OTA 即采用称为 “Tangle ( 缠结 )” 的 DAG 拓扑结构 , 其共识过程以交易 ( 而非区块 ) 为粒度 , 每个交易都引证其他两个交易的合法性、形成 DAG 网络 ,因而可以实现无区块 (Blockless) 共识 ; HashGraph共识则更进一步 , 基于 Gossip of gossip 协议和虚拟投票等技术 , 以交易为粒度 , 在特定的 DAG 结构上2020自动实现公平和快速的拜占庭容错共识 . 这些新型区块拓扑结构及其共识算法是未来发展趋势之一 , 建立在这些新型数据结构之上的共识算法也值得深入研究&quot;\n    // 第二个参数为分出关键词的个数\n    srcWordsWeight := g.C.ExtractWithWeight(srcStr, 22)\n    dstWordsWeight := g.C.ExtractWithWeight(dstStr, 11)\n    //fmt.Printf(&quot;srcWordsWeight: %v\\n&quot;, srcWordsWeight)\n    //fmt.Printf(&quot;dstWordsWeight: %v\\n&quot;, dstWordsWeight)\n\n    srcWords := make([]WordWeight, len(srcWordsWeight))\n    dstWords := make([]WordWeight, len(dstWordsWeight))\n    for i, ww := range srcWordsWeight {\n        word := WordWeight{Word: ww.Word, Weight: ww.Weight}\n        srcWords[i] = word\n    }\n    for i, ww := range dstWordsWeight {\n        word := WordWeight{Word: ww.Word, Weight: ww.Weight}\n        dstWords[i] = word\n    }\n    fmt.Printf(&quot;srcWords&amp;weight:%v\\n&quot;, srcWords)\n    fmt.Printf(&quot;dstWords&amp;weight:%v\\n&quot;, dstWords)\n\n    distance, err := SimHashSimilar64(srcWords, dstWords)\n    if err != nil {\n        fmt.Printf(&quot;failed: %v&quot;, err)\n    }\n\n    fmt.Printf(&quot;SimHashSimilar distance: %v&quot;, distance)\n}\n\n\n\n\n// 传入两个WordWeight类型的列表返回相似度值\nfunc SimHashSimilar64(srcWordWeighs, dstWordWeights []WordWeight) (distance int, err error) {\n\n    srcFingerPrint, err := simhashFingerPrint64(srcWordWeighs)\n    if err != nil {\n        return\n    }\n    fmt.Println(&quot;srcFingerPrint: &quot;, srcFingerPrint)\n    dstFingerPrint, err := simhashFingerPrint64(dstWordWeights)\n    if err != nil {\n        return\n    }\n    fmt.Println(&quot;dstFingerPrint: &quot;, dstFingerPrint)\n\n    distance = hammingDistance(srcFingerPrint, dstFingerPrint)\n\n    return\n}\n\n// rewrite simhashFingerPrint\n// 使用64位hash指纹进行运算\n\nfunc simhashFingerPrint64(wordWeights []WordWeight) (fingerPrint []string, err error) {\n    // 使用64位创建64个元素的二进制权重\n    binaryWeights := make([]float64, 64)\n    for _, ww := range wordWeights {\n        bitHash := strHashBitCode64(ww.Word)\n        weights := calcWithWeight64(bitHash, ww.Weight) //binary每个元素与weight的乘积结果数组\n        binaryWeights, err = sliceInnerPlus64(binaryWeights, weights)    //对每个hash数组求和\n        //fmt.Printf(&quot;ww.Word:%v, bitHash:%v, ww.Weight:%v, binaryWeights: %v\\n&quot;, ww.Word,bitHash, ww.Weight, binaryWeights)\n        if err != nil {\n            return\n        }\n    }\n    fingerPrint = make([]string, 0)\n    // 将求和后的数组重新根据正负转化为2进制hash数组\n    for _, b := range binaryWeights {\n        if b &gt; 0 { // bit 1\n            fingerPrint = append(fingerPrint, &quot;1&quot;)\n        } else { // bit 0\n            fingerPrint = append(fingerPrint, &quot;0&quot;)\n        }\n    }\n    return\n}\n\n// rewrite strHashBitCoin 64bit\n// 返回一个64位的二进制字符串,也就是对这个关键字进行hash运算之后的hash字符串\nfunc strHashBitCode64(str string) string {\n    h := fnv.New64a()\n    h.Write([]byte(str))\n    b := int64(h.Sum64())\n    return fmt.Sprintf(&quot;%064b&quot;, b)\n}\n\n// binary每个元素与weight的乘积结果数组,重写为64位操作\n// 就是hash完关键字的64位二进制串上都变成 [ weight, -weight, -weight, ... ,weight]的形式\nfunc calcWithWeight64(bitHash string, weight float64) []float64 {\n    // 首先分割字符串\n    bitHashs := strings.Split(bitHash, &quot;&quot;)\n    // 构造一个长度为0的slice,之后往里添加元素\n    binarys := make([]float64, 0)\n\n    for _, bit := range bitHashs {\n        if bit == &quot;0&quot; {\n            // 根据simhash算法,如果这位上为0就乘以负的权值\n            binarys = append(binarys, float64(-1)*weight)\n        } else {\n            // 反正,这位为1就乘以正权值\n            binarys = append(binarys, float64(weight))\n        }\n    }\n    return binarys\n}\n\n// 对其每个求完权值并且进行完向量运算的64位hash特征串进行求和运算\n// 假设arr2为第n个关键字,那么arr1就是前n-1个关键字每一位带权hash的和\nfunc sliceInnerPlus64(arr1, arr2 [] float64) (dstArr []float64, err error) {\n\n    dstArr = make([]float64, len(arr1), len(arr1))\n\n    if arr1 == nil || arr2 == nil {\n        err = fmt.Errorf(&quot;sliceInnerPlus array nil&quot;)\n        return\n    }\n    if len(arr1) != len(arr2) {\n        err = fmt.Errorf(&quot;sliceInnerPlus array Length NOT match, %v != %v&quot;, len(arr1), len(arr2))\n        return\n    }\n\n    for i, v1 := range arr1 {\n        dstArr[i] = v1 + arr2[i]\n    }\n\n    return\n}\n\nfunc hammingDistance(arr1, arr2 []string) int {\n    count := 0\n    for i, v1 := range arr1 {\n        if v1 != arr2[i] {\n            count++\n        }\n    }\n\n    return count\n}\n</code></pre>\n<p>具体函数细节请移步GitHub源码~</p>\n<blockquote>\n<p>参考：</p>\n<p><a href=\"http://yanyiwu.com/work/2014/01/30/simhash-shi-xian-xiang-jie.html\">http://yanyiwu.com/work/2014/01/30/simhash-shi-xian-xiang-jie.html</a></p>\n<p><a href=\"https://wizardforcel.gitbooks.io/the-art-of-programming-by-july/content/06.03.html\">https://wizardforcel.gitbooks.io/the-art-of-programming-by-july/content/06.03.html</a></p>\n<p>关于更多的中文分词信息可以<a href=\"https://www.zhihu.com/question/19578687\">点击这里</a></p>\n<p>关于Hamming Distance点击 -&gt; <a href=\"https://baike.baidu.com/item/海明距离\">海明距离</a></p>\n</blockquote>\n', '2020-07-22', '2020-07-22', '0');
INSERT INTO `article_info` VALUES ('73', '操作系统-处理机调度模拟', '57', '# 处理机调度图形界面1.0版本\n\n> 我一直觉得我效率很低...但还是画出来了，用的PyQt5这个库做的简陋界面，很多功能缺失...算法残疾...\n>\n> 这篇博文以一个算法实例来说一下大体思路\n>\n> - 代码\n> - 思路\n> - 演示\n> - 不足\n> - 改进\n> - 对了我给搞上评论系统辽，虽然这人迹罕至，但俺还是希望阴差阳错戳进来的朋友可以互动一哈\n\n## 惯例先给代码好吧\n\n> 以最简单的FCFS算法为例子，总代码量可能有1000行左右\n>\n> 这个算法的代码比较短\n\n```python\nfrom PyQt5.QtWidgets import (QWidget,QLineEdit,QHBoxLayout,QTableWidget,QPushButton,QApplication,QVBoxLayout,QTableWidgetItem,\nQCheckBox,QAbstractItemView,QHeaderView,QLabel,QFrame)\nfrom PyQt5 import QtWidgets, QtCore\nfrom PyQt5.QtCore import Qt\nfrom builtins import super, str, range\nfrom PyQt5.QtGui import QFont,QColor\nfrom faker import Factory\nimport random, sys, operator\n\n# 引入数据结构\n# 定义每个进程基本数据结构\nclass Process:\n    def __init__(self, name, arrive_time, serve_time, static_class, ready=False, over=False):\n        self.name = name                                    # 进程名称\n        self.arrive_time = arrive_time                      # 到达时间\n        self.serve_time = serve_time                        # 服务时间\n        self.left_serve_time = serve_time                   # 剩余需要服务的时间\n        self.finish_time = 0                                # 完成时间\n        self.cycling_time = 0                               # 周转时间\n        self.w_cycling_time = 0                             # 带权周转时间\n        self.response_ratio = 0                             # 响应比\n        self.pre_queue = 0                                  # 定义现在所在的队列\n        self.pre_queue_tb = 0                               # 目前所在队列的时间片\n        self.used_time = 0                                  # 已经使用的时间，也就是（服务时间 - 剩余	                                                                                         服务时间）\n        self.ready = ready                                  # 记录就绪状态\n        self.over = over                                    # 记录完成状态\n        self.static_class = static_class                    # 人为赋予静态优先级\n\n# 现来先服务作业调度算法\ndef fcfs(processes): # 到达时间小的优先\n    sum_cycling_time = 0\n    sum_w_cycling_time = 0\n    number = len(processes)\n    over_list = []\n    min_key = 0\n    fin_name = []\n    name_string = \'\'\n    time_string = \'带权周转时间：\'\n    last_infor = []\n    running_time = 0\n    while processes:\n        min = processes[0].arrive_time\n        for i in range(len(processes)):\n            if processes[i].arrive_time <= min:\n                min = processes[i].arrive_time\n                min_key = i\n        running_time += processes[min_key].serve_time\n        # 计算相关参数\n        processes[min_key].cycling_time = running_time - processes[min_key].arrive_time\n        processes[min_key].w_cycling_time = processes[min_key].cycling_time / processes[min_key].serve_time\n        sum_cycling_time += processes[min_key].cycling_time\n        sum_w_cycling_time += processes[min_key].w_cycling_time\n        \n        over_list.append(processes.pop(min_key))\n    for i in range(len(over_list)):\n        print(over_list[i].name)\n        name_string += (over_list[i].name+\'   \')\n        fin_name.append(over_list[i].name)\n    a_c_time = sum_cycling_time/number\n    a_w_c_time = sum_w_cycling_time/number\n    print(\'平均周转时间：\' + str(a_c_time))\n    print(\'平均带权周转时间：\' + str(a_w_c_time/number))\n    time_string += (str(a_c_time) + \'    平均带权周转时间：\' + str(a_w_c_time))\n    last_infor.append(name_string)\n    last_infor.append(time_string)\n    # return fin_name\n    return last_infor\n\nclass ui(QWidget):\n    def __init__(self):\n        super(ui, self).__init__()\n        self.setupUI()\n        self.id = 1\n        self.lines = []\n        self.editable = True\n        self.des_sort = True\n        self.faker = Factory.create()\n\n        self.btn_add.clicked.connect(self.add_line)\n        self.btn_del.clicked.connect(self.del_line)\n        self.btn_modify.clicked.connect(self.modify_line)\n        self.btn_set_middle.clicked.connect(self.middle)\n        self.btn_get_info.clicked.connect(self.g_info)\n\n        self.table.cellChanged.connect(self.cellchange)\n\n        global original_processes                # 这里我们定义全局变量 - 原始进程列表，是一个二维列表\n\n    def setupUI(self):\n        self.setWindowTitle(\'数据测试\')\n        self.resize(720,420)\n        \n        self.table = QTableWidget(self)\n\n        self.btn_add = QPushButton(\'增加\')\n        self.btn_del = QPushButton(\'删除\')\n        self.btn_modify = QPushButton(\'可以编辑\')\n        self.btn_set_middle = QPushButton(\'文字居中\')\n        self.btn_get_info = QPushButton(\'生成调度序列\')\n    \n        # 弹簧控件\n        self.spacerItem = QtWidgets.QSpacerItem(20, 20, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)\n        \n        # 垂直布局，使用嵌套布局方式\n        # 我们把所有按钮按照盒布局-垂直布局方式，构成嵌套布局的一个块\n        # 按照设置的方式依此从上到下\n        self.vbox = QVBoxLayout()\n        self.vbox.addWidget(self.btn_add)\n        self.vbox.addWidget(self.btn_del)\n        self.vbox.addWidget(self.btn_modify)\n        self.vbox.addWidget(self.btn_set_middle)\n        self.vbox.addWidget(self.btn_get_info)\n        self.vbox.addSpacerItem(self.spacerItem)            \n        \n        self.txt = QLabel()                             # 这是进行操作时显示在最左下角的提示信息\n        self.txt.setMinimumHeight(50)                   # 限定控件大小\n\n        self.lab_over = QLabel(\'调度顺序\')               # 输出队列顺序\n        self.lab_over.setMinimumHeight(20)\n        self.over_Edit = QLineEdit(self)\n        self.over_Edit.setMinimumHeight(25)\n\n        self.lab_time = QLabel(\'平均周转时间和平均带权周转时间\')\n        self.avrtime_edit = QLineEdit(self)\n\n        # 垂直布局\n        # 把表格和下面的操作提示文本信息按照垂直布局设置，作为嵌套布局方式的另一部分\n        self.vbox2 = QVBoxLayout()                          \n        self.vbox2.addWidget(self.table)                    # 将表格和下面的操作提示放入垂直布局，先放表格\n        self.vbox2.addWidget(self.lab_over)                 # 放输出队列\n        self.vbox2.addWidget(self.over_Edit)\n        self.vbox2.addWidget(self.lab_time)\n        self.vbox2.addWidget(self.avrtime_edit)\n\n        self.vbox2.addWidget(self.txt)                      # 再放文本框\n\n        # 水平布局\n        # 这是将上述两个布局方式作为整体布局的元素，vbox和vbox2共同放入水平布局\n        self.hbox = QHBoxLayout()                          \n        self.hbox.addLayout(self.vbox2)                     # 将这样就会自左向右，先放表格，\n        self.hbox.addLayout(self.vbox)                      # 再放按钮\n\n        # 将水平布局放入总体布局\n        self.setLayout(self.hbox)\n\n        # 表格基本属性设置   \n        self.table.setColumnCount(6)                                    # 设置列数\n        self.table.horizontalHeader().setDefaultAlignment(QtCore.Qt.AlignCenter)\n        self.headers = [\'ID\',\'选择\',\'进程名\', \'到达时间\', \'服务时间\', \'静态优先级\']      # 设置每列标题\n        self.table.setHorizontalHeaderLabels(self.headers)              # 导入\n        self.table.verticalHeader().setVisible(False)                   # 隐藏垂直表头\n        self.show()\n\n    # 添加行\n    def add_line(self):\n        self.table.cellChanged.disconnect()\n        row = self.table.rowCount()                                     # 获取目前所有行的数量\n        self.table.setRowCount(row + 1)\n        id = str(self.id)\n\n        # 生成复选框， 并设置居中显示\n        ck = QCheckBox()\n        h = QHBoxLayout()\n        h.setAlignment(Qt.AlignCenter)\n        h.addWidget(ck)\n        w = QWidget()\n        w.setLayout(h)\n\n        # 变量由faker自动生成\n        name = self.faker.name()\n        arr_time = str(random.randint(0,9))\n        ser_time = str(random.randint(0,9))\n        sta_class = str(random.randint(0,9))\n\n        # 设置新建行的数据\n        self.table.setItem(row,0,QTableWidgetItem(id))\n        self.table.setCellWidget(row,1,w)\n        self.table.setItem(row,2,QTableWidgetItem(name))\n        self.table.setItem(row,3,QTableWidgetItem(arr_time))\n        self.table.setItem(row,4,QTableWidgetItem(ser_time))\n        self.table.setItem(row,5,QTableWidgetItem(sta_class))\n\n        self.id += 1                                                        # 设置完不要忘记id加一\n        self.lines.append([id,ck,name,arr_time,ser_time,sta_class])\n        self.settext(\'自动生成随机一行数据！,checkbox设置为居中显示\')\n        self.table.cellChanged.connect(self.cellchange)\n\n    # 删除行\n    def del_line(self):\n        removeline = []\n        for line in self.lines:\n            if line[1].isChecked():\n                row = self.table.rowCount()\n                for x in range(row,0,-1):\n                    if line[0] == self.table.item(x - 1,0).text():\n                        self.table.removeRow(x - 1)\n                        removeline.append(line)\n        for line in removeline:\n            self.lines.remove(line)\n        self.settext(\'删除checkbox中选中状态的行\')\n\n    def modify_line(self):\n        if self.editable == True:\n            self.table.setEditTriggers(QAbstractItemView.NoEditTriggers)\n            self.btn_modify.setText(\'禁止编辑\')\n            self.editable = False\n        else:\n            self.table.setEditTriggers(QAbstractItemView.AllEditTriggers)\n            self.btn_modify.setText(\'可以编辑\')\n            self.editable = True\n        self.settext(\'设置是否可以编辑表格信息\')\n\n    def middle(self):\n        row = self.table.rowCount()\n        for x in range(row):\n            for y in range(6):\n                if y != 1:\n                    item = self.table.item(x,y)\n                    item.setTextAlignment(Qt.AlignCenter)\n                else:\n                    pass\n        self.settext(\'将文字居中显示\')  \n\n    def cellchange(self,row,col):\n        item = self.table.item(row,col)\n        txt = item.text()\n        self.settext(\'第%s行，第%s列 , 数据改变为:%s\'%(row,col,txt))\n\n    def g_info(self):\n        # 我们每次使用这个功能时先把全变量原始进程列表 -- original_processes --清空好吧\n        original_processes = []\n        row = self.table.rowCount()\n\n        for j in range(row):                            # 有几行就有几个进程\n            na = self.table.item(j,2).text()\n            at = int(self.table.item(j,3).text())\n            st = int(self.table.item(j,4).text())\n            sc = int(self.table.item(j,5).text())\n            p = Process(na, at, st, sc)\n            original_processes.append(p)\n            print(na+\' \'+str(at)+\' \'+str(st)+\' \'+str(sc))\n\n        \'\'\'\n        由于第一个进程不一定就是到达时间最短的进程，所以我们先按照\n        到达时间给进程排个序\n        \'\'\'\n        _sorted_processes = original_processes[:]\n        _sorted_processes.sort(key=operator.attrgetter(\'arrive_time\'))\n\n        infor_list = fcfs(_sorted_processes)\n        self.avrtime_edit.setText(str(infor_list[1]))\n        self.over_Edit.setText(str(infor_list[0]))\n        self.settext(\'获取表格信息，生成调度序列，计算平均、平均带权周转时间，并显示\')\n    \n    def settext(self,txt):\n        font = QFont(\'微软雅黑\',10)\n        self.txt.setFont(font)\n        self.txt.setText(txt)  \n\n\nif __name__ == \'__main__\':\n    app = QApplication(sys.argv)\n    ui = ui()\n    sys.exit(app.exec_())\n```\n\n## 大体思路\n\n#### 数据结构定义及功能算法部分\n\n```python\n#  引入数据结构\n# 定义每个进程基本数据结构\nclass Process:\n    def __init__(self, name, arrive_time, serve_time, static_class, ready=False, over=False):\n        self.name = name                                    # 进程名称\n        self.arrive_time = arrive_time                      # 到达时间\n        self.serve_time = serve_time                        # 服务时间\n        self.left_serve_time = serve_time                   # 剩余需要服务的时间\n        self.finish_time = 0                                # 完成时间\n        self.cycling_time = 0                               # 周转时间\n        self.w_cycling_time = 0                             # 带权周转时间\n        self.response_ratio = 0                             # 响应比\n        self.pre_queue = 0                                  # 定义现在所在的队列\n        self.pre_queue_tb = 0                               # 目前所在队列的时间片\n        self.used_time = 0                                  # 已经使用的时间，也就是（服务时间 - 剩余服务时间）\n        self.ready = ready                                  # 记录就绪状态\n        self.over = over                                    # 记录完成状态\n        self.static_class = static_class                    # 人为赋予静态优先级\n\n\n# 现来先服务作业调度算法\ndef fcfs(processes): # 到达时间小的优先\n   \n    sum_cycling_time = 0\n    sum_w_cycling_time = 0\n    number = len(processes)\n    over_list = []\n    min_key = 0\n    fin_name = []\n    name_string = \'\'\n    time_string = \'带权周转时间：\'\n    last_infor = []\n    running_time = 0\n    while processes:\n        min = processes[0].arrive_time\n        for i in range(len(processes)):\n            if processes[i].arrive_time <= min:\n                min = processes[i].arrive_time\n                min_key = i\n\n        running_time += processes[min_key].serve_time\n        processes[min_key].cycling_time = running_time - processes[min_key].arrive_time\n        processes[min_key].w_cycling_time = processes[min_key].cycling_time / processes[min_key].serve_time\n        sum_cycling_time += processes[min_key].cycling_time\n        sum_w_cycling_time += processes[min_key].w_cycling_time\n\n        over_list.append(processes.pop(min_key))\n    for i in range(len(over_list)):\n        print(over_list[i].name)\n        name_string += (over_list[i].name+\'   \')\n        fin_name.append(over_list[i].name)\n\n    a_c_time = sum_cycling_time/number\n    a_w_c_time = sum_w_cycling_time/number\n    print(\'平均周转时间：\' + str(a_c_time))\n    print(\'平均带权周转时间：\' + str(a_w_c_time/number))\n    time_string += (str(a_c_time) + \'    平均带权周转时间：\' + str(a_w_c_time))\n\n    last_infor.append(name_string)\n    last_infor.append(time_string)\n    # return fin_name\n    return last_infor\n\n```\n\n这部分内容在之前的博客中有大体的讲，不过好像是重构了，过段时间应该还要重构。\n\n这里要注意返回的列表有两项，分别是调度完之后的作业or进程名称顺序字符串，还有平均周转时间和平均带权周转时间的时间参数字符串。就不多讲了。\n\n在每次执行完一个作业or进程之后，会进行一个周转时间和带权周转时间的计算，方便计算性能。\n\n其余和之前差不多。\n\n#### GUI部分\n\n引入的库和模块\n\n```python\nfrom PyQt5.QtWidgets import (QWidget,QLineEdit,QHBoxLayout,QTableWidget,QPushButton,QApplication,QVBoxLayout,QTableWidgetItem,QCheckBox,QAbstractItemView,QHeaderView,QLabel,QFrame)\nfrom PyQt5 import QtWidgets, QtCore\nfrom PyQt5.QtCore import Qt\nfrom builtins import super, str, range\nfrom PyQt5.QtGui import QFont,QColor\nfrom faker import Factory\nimport random, sys, operator\n\n```\n\n主要用了是PyQt5的模块，另外加一些内置的计算模块，像后面的算法还用到numpy等科学计算模块\n\n语法、思路、排版、实现\n\n> 直接往代码里写了啊\n\n```python\nclass ui(QWidget):                             # 继承QWidget\n    def __init__(self):\n        super(ui, self).__init__()\n        self.setupUI()\n        self.id = 1\n        self.lines = []\n        self.editable = True\n        self.des_sort = True\n        self.faker = Factory.create()			# faker库是数据伪造生成器，后续会搬运一篇博文讲\n\n        \'\'\'\n        这里面主要使用了 \n        按钮-button\n        标签-lable\n        编辑单行文本框-editline\n        表格-table\n        这几个控件\n        我觉得难点主要在于不熟悉这些控件的方法，英语又不好官方文档看明白是不可能的...对了6级第一次裸考没过\n        \'\'\'\n        # 按钮绑定事件 \n        \'\'\'\n        主要事件\n        add_line 表格添加行\n        del_line 表格删除行\n        modify_line 控制表格是否可以被编辑\n        middle 设置表格文字居中显示\n        cellchange 根据相关触发的操作提示你的操作是干嘛的\n        \'\'\'\n        self.btn_add.clicked.connect(self.add_line)\n        self.btn_del.clicked.connect(self.del_line)\n        self.btn_modify.clicked.connect(self.modify_line)\n        self.btn_set_middle.clicked.connect(self.middle)\n        self.btn_get_info.clicked.connect(self.g_info)\n\n        self.table.cellChanged.connect(self.cellchange)\n\n        global original_processes               # 这里我们定义全局变量 - 原始进程列表，是一个二维列表\n\n\n    def setupUI(self):\n        # 控件的排版，做的时候嵌套布局那一块觉得自己是真的学到了，很有趣，基本设置Google Baidu都可找到\n        self.setWindowTitle(\'数据测试\')\n        self.resize(720,420)\n\n        self.table = QTableWidget(self)\n\n        self.btn_add = QPushButton(\'增加\')\n        self.btn_del = QPushButton(\'删除\')\n        self.btn_modify = QPushButton(\'可以编辑\')\n        self.btn_set_middle = QPushButton(\'文字居中\')\n        self.btn_get_info = QPushButton(\'生成调度序列\')\n    \n        # 弹簧控件，这个不是很明白\n        self.spacerItem = QtWidgets.QSpacerItem(20, 20, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)\n        \n        # 垂直布局，使用嵌套布局方式\n        # 我们把所有按钮按照盒布局-垂直布局方式，构成嵌套布局的一个块\n        # 按照设置的方式依此从上到下\n        self.vbox = QVBoxLayout()\n        self.vbox.addWidget(self.btn_add)\n        self.vbox.addWidget(self.btn_del)\n        self.vbox.addWidget(self.btn_modify)\n        self.vbox.addWidget(self.btn_set_middle)\n        self.vbox.addWidget(self.btn_get_info)\n        self.vbox.addSpacerItem(self.spacerItem)            \n        \n        self.txt = QLabel()                             # 这是进行操作时显示在最左下角的提示信息\n        self.txt.setMinimumHeight(50)                   # 限定控件大小\n\n        self.lab_over = QLabel(\'调度顺序\')               # 输出队列顺序\n        self.lab_over.setMinimumHeight(20)\n        self.over_Edit = QLineEdit(self)\n        self.over_Edit.setMinimumHeight(25)\n\n        self.lab_time = QLabel(\'平均周转时间和平均带权周转时间\')\n        self.avrtime_edit = QLineEdit(self)\n\n        # 垂直布局\n        # 把表格和下面的操作提示文本信息按照垂直布局设置，作为嵌套布局方式的另一部分\n        self.vbox2 = QVBoxLayout()                          \n        self.vbox2.addWidget(self.table)                    # 将表格和下面的操作提示放入垂直布局，先放表格\n        self.vbox2.addWidget(self.lab_over)                 # 放输出队列\n        self.vbox2.addWidget(self.over_Edit)\n        self.vbox2.addWidget(self.lab_time)\n        self.vbox2.addWidget(self.avrtime_edit)\n\n        self.vbox2.addWidget(self.txt)                      # 再放文本框\n\n        # 水平布局\n        # 这是将上述两个布局方式作为整体布局的元素，vbox和vbox2共同放入水平布局\n        self.hbox = QHBoxLayout()                          \n        self.hbox.addLayout(self.vbox2)                     # 将这样就会自左向右，先放表格，\n        self.hbox.addLayout(self.vbox)                      # 再放按钮\n\n        # 将水平布局放入总体布局\n        self.setLayout(self.hbox)\n\n        # 表格基本属性设置   \n        self.table.setColumnCount(6)                                    # 设置列数\n        self.table.horizontalHeader().setDefaultAlignment(QtCore.Qt.AlignCenter)\n        self.headers = [\'ID\',\'选择\',\'进程名\', \'到达时间\', \'服务时间\', \'静态优先级\']      # 设置每列标题\n        self.table.setHorizontalHeaderLabels(self.headers)              # 导入\n        self.table.verticalHeader().setVisible(False)                   # 隐藏垂直表头\n        self.show()\n\n    # 添加行\n    def add_line(self):\n        self.table.cellChanged.disconnect()\n        row = self.table.rowCount()                                     # 获取目前所有行的数量\n        self.table.setRowCount(row + 1)\n        id = str(self.id)\n\n        # 生成复选框， 并设置居中显示\n        ck = QCheckBox()\n        h = QHBoxLayout()\n        h.setAlignment(Qt.AlignCenter)\n        h.addWidget(ck)\n        w = QWidget()\n        w.setLayout(h)\n\n        # 变量由faker自动生成\n        name = self.faker.name()\n        arr_time = str(random.randint(0,9))\n        ser_time = str(random.randint(0,9))\n        sta_class = str(random.randint(0,9))\n\n        # 设置新建行的数据\n        self.table.setItem(row,0,QTableWidgetItem(id))\n        self.table.setCellWidget(row,1,w)\n        self.table.setItem(row,2,QTableWidgetItem(name))\n        self.table.setItem(row,3,QTableWidgetItem(arr_time))\n        self.table.setItem(row,4,QTableWidgetItem(ser_time))\n        self.table.setItem(row,5,QTableWidgetItem(sta_class))\n\n        self.id += 1                                                        # 设置完不要忘记id加一\n        self.lines.append([id,ck,name,arr_time,ser_time,sta_class])\n        self.settext(\'自动生成随机一行数据！,checkbox设置为居中显示\')\n        self.table.cellChanged.connect(self.cellchange)\n\n    # 删除行\n    def del_line(self):\n        removeline = []\n        for line in self.lines:\n            if line[1].isChecked():\n                row = self.table.rowCount()\n                for x in range(row,0,-1):\n                    if line[0] == self.table.item(x - 1,0).text():\n                        self.table.removeRow(x - 1)\n                        removeline.append(line)\n        for line in removeline:\n            self.lines.remove(line)\n        self.settext(\'删除checkbox中选中状态的行\')\n\n    def modify_line(self):\n        if self.editable == True:\n            self.table.setEditTriggers(QAbstractItemView.NoEditTriggers)\n            self.btn_modify.setText(\'禁止编辑\')\n            self.editable = False\n        else:\n            self.table.setEditTriggers(QAbstractItemView.AllEditTriggers)\n            self.btn_modify.setText(\'可以编辑\')\n            self.editable = True\n        self.settext(\'设置是否可以编辑表格信息\')\n\n    def middle(self):\n        row = self.table.rowCount()\n        for x in range(row):\n            for y in range(6):\n                if y != 1:\n                    item = self.table.item(x,y)\n                    item.setTextAlignment(Qt.AlignCenter)\n                else:\n                    pass\n        self.settext(\'将文字居中显示\')  \n\n    def cellchange(self,row,col):\n        item = self.table.item(row,col)\n        txt = item.text()\n        self.settext(\'第%s行，第%s列 , 数据改变为:%s\'%(row,col,txt))\n\n    def g_info(self):\n        # 我们每次使用这个功能时先把全变量原始进程列表 -- original_processes --清空好吧\n        # 这个函数获取表格数据存入队列，初始化进程信息加入列表，最后调主算法函数进行模拟调度，最后返回信息\n        original_processes = []\n        row = self.table.rowCount()\n\n        for j in range(row):                            # 有几行就有几个进程\n            na = self.table.item(j,2).text()\n            at = int(self.table.item(j,3).text())\n            st = int(self.table.item(j,4).text())\n            sc = int(self.table.item(j,5).text())\n            p = Process(na, at, st, sc)\n            original_processes.append(p)\n            print(na+\' \'+str(at)+\' \'+str(st)+\' \'+str(sc))\n\n        \'\'\'\n        由于第一个进程不一定就是到达时间最短的进程，所以我们先按照\n        到达时间给进程排个序\n        这是后来才想到的，还有很多诸如此类的bug...脑壳疼\n        \'\'\'\n        _sorted_processes = original_processes[:]\n        _sorted_processes.sort(key=operator.attrgetter(\'arrive_time\'))\n\n        infor_list = fcfs(_sorted_processes)\n        # 讲返回的信息填入文本框\n        self.avrtime_edit.setText(str(infor_list[1]))\n        self.over_Edit.setText(str(infor_list[0]))\n        self.settext(\'获取表格信息，生成调度序列，计算平均、平均带权周转时间，并显示\')\n    # 提示字体的设置\n    def settext(self,txt):\n        font = QFont(\'微软雅黑\',10)\n        self.txt.setFont(font)\n        self.txt.setText(txt)  \n```\n\n最后就...\n\n```python\nif __name__ == \'__main__\':\n    app = QApplication(sys.argv)\n    ui = ui()\n    sys.exit(app.exec_())\n```\n\n> 大体框架写完之后觉得好多东西并没有那么难，只是你没有见过所以觉得很唬人，然而我觉得我coding效率还是太低了，诶\n\n## 演示\n\n- 主页面\n\n  ![](https://i.loli.net/2019/03/13/5c87d832bdbec.png)\n\n- 添加行并自动生成数据\n\n  ![](https://i.loli.net/2019/03/13/5c87d8c84a5f1.png)\n\n- 更改数据\n\n  ![](https://i.loli.net/2019/03/13/5c87d8d775837.png)\n\n- 居中对齐\n\n  ![](https://i.loli.net/2019/03/13/5c87d8eb66d3b.png)\n\n- 生成序列并显示调度顺序和时间效率\n\n  ![](https://i.loli.net/2019/03/13/5c87d91dca9a2.png)\n\n- 删除选中行\n\n  ![](https://i.loli.net/2019/03/13/5c87d935206e1.png)\n\n  ![](https://i.loli.net/2019/03/13/5c87d93f9b163.png)\n\n  > 完事了就，太简陋···但是一想这东西用c/c++写就也太麻烦了吧，python真好~\n\n## 不足与改进思路\n\n#### 不足\n\n- 算法有问题，数据容错率极低，经常因为数据不规范就原地崩\n- 没有实现 作业/进程 数据可从外部导入的功能\n- 没实现 单步执行 的功能，我想这是最要紧的...\n- 没有 相同进程不同算法性能数据比较 功能\n- 不够集成\n\n总体看来，就是只实现了一个大体的demo，还有很多需要改进\n\n#### 改进思路\n\n- 算法重构，昨天调的时候觉得太乱了，而且如果要单步执行的话目前算法应该不能达到要求\n- 优化GUI\n- 还是算法吧，数据容错性太差\n- 添加从外部文件导入数据功能\n\n> 题外话：最近有些焦虑，铺天盖地的说2019计算机考研哪哪都炸，初试神仙打架复试百里挑一，985211各路神仙跨考计算机的数不过来，感觉350都不叫分了。就一股脑都来吃计算机这碗饭，就连调剂的生源都不错，更何况一堆搞ACM的、手里拿着一大堆项目、顶级论文发了好几篇的神仙也...越来越觉得路难走，实力又真是差十万八千里，就越发急于求成，想很快可以出成绩看到结果。输在了起跑线上在后面得付出更多的努力，然而更多时候只是停留嘴面实际行动又不及十分之一。可能就不具备那种潜质再者说没有足够的动力一直激励自己。但，但行好事莫问前程吧。今天20了...真快，可以再加把劲\n>\n> 写的太晚了难免有纰漏，望海涵\n\n[源码地址](https://github.com/lizonglin313/-python-)\n\n', '<h1 id=\"h1--1-0-\"><a name=\"处理机调度图形界面1.0版本\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>处理机调度图形界面1.0版本</h1><blockquote>\n<p>我一直觉得我效率很低…但还是画出来了，用的PyQt5这个库做的简陋界面，很多功能缺失…算法残疾…</p>\n<p>这篇博文以一个算法实例来说一下大体思路</p>\n<ul>\n<li>代码</li><li>思路</li><li>演示</li><li>不足</li><li>改进</li><li>对了我给搞上评论系统辽，虽然这人迹罕至，但俺还是希望阴差阳错戳进来的朋友可以互动一哈</li></ul>\n</blockquote>\n<h2 id=\"h2-u60EFu4F8Bu5148u7ED9u4EE3u7801u597Du5427\"><a name=\"惯例先给代码好吧\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>惯例先给代码好吧</h2><blockquote>\n<p>以最简单的FCFS算法为例子，总代码量可能有1000行左右</p>\n<p>这个算法的代码比较短</p>\n</blockquote>\n<pre><code class=\"lang-python\">from PyQt5.QtWidgets import (QWidget,QLineEdit,QHBoxLayout,QTableWidget,QPushButton,QApplication,QVBoxLayout,QTableWidgetItem,\nQCheckBox,QAbstractItemView,QHeaderView,QLabel,QFrame)\nfrom PyQt5 import QtWidgets, QtCore\nfrom PyQt5.QtCore import Qt\nfrom builtins import super, str, range\nfrom PyQt5.QtGui import QFont,QColor\nfrom faker import Factory\nimport random, sys, operator\n\n# 引入数据结构\n# 定义每个进程基本数据结构\nclass Process:\n    def __init__(self, name, arrive_time, serve_time, static_class, ready=False, over=False):\n        self.name = name                                    # 进程名称\n        self.arrive_time = arrive_time                      # 到达时间\n        self.serve_time = serve_time                        # 服务时间\n        self.left_serve_time = serve_time                   # 剩余需要服务的时间\n        self.finish_time = 0                                # 完成时间\n        self.cycling_time = 0                               # 周转时间\n        self.w_cycling_time = 0                             # 带权周转时间\n        self.response_ratio = 0                             # 响应比\n        self.pre_queue = 0                                  # 定义现在所在的队列\n        self.pre_queue_tb = 0                               # 目前所在队列的时间片\n        self.used_time = 0                                  # 已经使用的时间，也就是（服务时间 - 剩余                                                                                             服务时间）\n        self.ready = ready                                  # 记录就绪状态\n        self.over = over                                    # 记录完成状态\n        self.static_class = static_class                    # 人为赋予静态优先级\n\n# 现来先服务作业调度算法\ndef fcfs(processes): # 到达时间小的优先\n    sum_cycling_time = 0\n    sum_w_cycling_time = 0\n    number = len(processes)\n    over_list = []\n    min_key = 0\n    fin_name = []\n    name_string = &#39;&#39;\n    time_string = &#39;带权周转时间：&#39;\n    last_infor = []\n    running_time = 0\n    while processes:\n        min = processes[0].arrive_time\n        for i in range(len(processes)):\n            if processes[i].arrive_time &lt;= min:\n                min = processes[i].arrive_time\n                min_key = i\n        running_time += processes[min_key].serve_time\n        # 计算相关参数\n        processes[min_key].cycling_time = running_time - processes[min_key].arrive_time\n        processes[min_key].w_cycling_time = processes[min_key].cycling_time / processes[min_key].serve_time\n        sum_cycling_time += processes[min_key].cycling_time\n        sum_w_cycling_time += processes[min_key].w_cycling_time\n\n        over_list.append(processes.pop(min_key))\n    for i in range(len(over_list)):\n        print(over_list[i].name)\n        name_string += (over_list[i].name+&#39;   &#39;)\n        fin_name.append(over_list[i].name)\n    a_c_time = sum_cycling_time/number\n    a_w_c_time = sum_w_cycling_time/number\n    print(&#39;平均周转时间：&#39; + str(a_c_time))\n    print(&#39;平均带权周转时间：&#39; + str(a_w_c_time/number))\n    time_string += (str(a_c_time) + &#39;    平均带权周转时间：&#39; + str(a_w_c_time))\n    last_infor.append(name_string)\n    last_infor.append(time_string)\n    # return fin_name\n    return last_infor\n\nclass ui(QWidget):\n    def __init__(self):\n        super(ui, self).__init__()\n        self.setupUI()\n        self.id = 1\n        self.lines = []\n        self.editable = True\n        self.des_sort = True\n        self.faker = Factory.create()\n\n        self.btn_add.clicked.connect(self.add_line)\n        self.btn_del.clicked.connect(self.del_line)\n        self.btn_modify.clicked.connect(self.modify_line)\n        self.btn_set_middle.clicked.connect(self.middle)\n        self.btn_get_info.clicked.connect(self.g_info)\n\n        self.table.cellChanged.connect(self.cellchange)\n\n        global original_processes                # 这里我们定义全局变量 - 原始进程列表，是一个二维列表\n\n    def setupUI(self):\n        self.setWindowTitle(&#39;数据测试&#39;)\n        self.resize(720,420)\n\n        self.table = QTableWidget(self)\n\n        self.btn_add = QPushButton(&#39;增加&#39;)\n        self.btn_del = QPushButton(&#39;删除&#39;)\n        self.btn_modify = QPushButton(&#39;可以编辑&#39;)\n        self.btn_set_middle = QPushButton(&#39;文字居中&#39;)\n        self.btn_get_info = QPushButton(&#39;生成调度序列&#39;)\n\n        # 弹簧控件\n        self.spacerItem = QtWidgets.QSpacerItem(20, 20, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)\n\n        # 垂直布局，使用嵌套布局方式\n        # 我们把所有按钮按照盒布局-垂直布局方式，构成嵌套布局的一个块\n        # 按照设置的方式依此从上到下\n        self.vbox = QVBoxLayout()\n        self.vbox.addWidget(self.btn_add)\n        self.vbox.addWidget(self.btn_del)\n        self.vbox.addWidget(self.btn_modify)\n        self.vbox.addWidget(self.btn_set_middle)\n        self.vbox.addWidget(self.btn_get_info)\n        self.vbox.addSpacerItem(self.spacerItem)            \n\n        self.txt = QLabel()                             # 这是进行操作时显示在最左下角的提示信息\n        self.txt.setMinimumHeight(50)                   # 限定控件大小\n\n        self.lab_over = QLabel(&#39;调度顺序&#39;)               # 输出队列顺序\n        self.lab_over.setMinimumHeight(20)\n        self.over_Edit = QLineEdit(self)\n        self.over_Edit.setMinimumHeight(25)\n\n        self.lab_time = QLabel(&#39;平均周转时间和平均带权周转时间&#39;)\n        self.avrtime_edit = QLineEdit(self)\n\n        # 垂直布局\n        # 把表格和下面的操作提示文本信息按照垂直布局设置，作为嵌套布局方式的另一部分\n        self.vbox2 = QVBoxLayout()                          \n        self.vbox2.addWidget(self.table)                    # 将表格和下面的操作提示放入垂直布局，先放表格\n        self.vbox2.addWidget(self.lab_over)                 # 放输出队列\n        self.vbox2.addWidget(self.over_Edit)\n        self.vbox2.addWidget(self.lab_time)\n        self.vbox2.addWidget(self.avrtime_edit)\n\n        self.vbox2.addWidget(self.txt)                      # 再放文本框\n\n        # 水平布局\n        # 这是将上述两个布局方式作为整体布局的元素，vbox和vbox2共同放入水平布局\n        self.hbox = QHBoxLayout()                          \n        self.hbox.addLayout(self.vbox2)                     # 将这样就会自左向右，先放表格，\n        self.hbox.addLayout(self.vbox)                      # 再放按钮\n\n        # 将水平布局放入总体布局\n        self.setLayout(self.hbox)\n\n        # 表格基本属性设置   \n        self.table.setColumnCount(6)                                    # 设置列数\n        self.table.horizontalHeader().setDefaultAlignment(QtCore.Qt.AlignCenter)\n        self.headers = [&#39;ID&#39;,&#39;选择&#39;,&#39;进程名&#39;, &#39;到达时间&#39;, &#39;服务时间&#39;, &#39;静态优先级&#39;]      # 设置每列标题\n        self.table.setHorizontalHeaderLabels(self.headers)              # 导入\n        self.table.verticalHeader().setVisible(False)                   # 隐藏垂直表头\n        self.show()\n\n    # 添加行\n    def add_line(self):\n        self.table.cellChanged.disconnect()\n        row = self.table.rowCount()                                     # 获取目前所有行的数量\n        self.table.setRowCount(row + 1)\n        id = str(self.id)\n\n        # 生成复选框， 并设置居中显示\n        ck = QCheckBox()\n        h = QHBoxLayout()\n        h.setAlignment(Qt.AlignCenter)\n        h.addWidget(ck)\n        w = QWidget()\n        w.setLayout(h)\n\n        # 变量由faker自动生成\n        name = self.faker.name()\n        arr_time = str(random.randint(0,9))\n        ser_time = str(random.randint(0,9))\n        sta_class = str(random.randint(0,9))\n\n        # 设置新建行的数据\n        self.table.setItem(row,0,QTableWidgetItem(id))\n        self.table.setCellWidget(row,1,w)\n        self.table.setItem(row,2,QTableWidgetItem(name))\n        self.table.setItem(row,3,QTableWidgetItem(arr_time))\n        self.table.setItem(row,4,QTableWidgetItem(ser_time))\n        self.table.setItem(row,5,QTableWidgetItem(sta_class))\n\n        self.id += 1                                                        # 设置完不要忘记id加一\n        self.lines.append([id,ck,name,arr_time,ser_time,sta_class])\n        self.settext(&#39;自动生成随机一行数据！,checkbox设置为居中显示&#39;)\n        self.table.cellChanged.connect(self.cellchange)\n\n    # 删除行\n    def del_line(self):\n        removeline = []\n        for line in self.lines:\n            if line[1].isChecked():\n                row = self.table.rowCount()\n                for x in range(row,0,-1):\n                    if line[0] == self.table.item(x - 1,0).text():\n                        self.table.removeRow(x - 1)\n                        removeline.append(line)\n        for line in removeline:\n            self.lines.remove(line)\n        self.settext(&#39;删除checkbox中选中状态的行&#39;)\n\n    def modify_line(self):\n        if self.editable == True:\n            self.table.setEditTriggers(QAbstractItemView.NoEditTriggers)\n            self.btn_modify.setText(&#39;禁止编辑&#39;)\n            self.editable = False\n        else:\n            self.table.setEditTriggers(QAbstractItemView.AllEditTriggers)\n            self.btn_modify.setText(&#39;可以编辑&#39;)\n            self.editable = True\n        self.settext(&#39;设置是否可以编辑表格信息&#39;)\n\n    def middle(self):\n        row = self.table.rowCount()\n        for x in range(row):\n            for y in range(6):\n                if y != 1:\n                    item = self.table.item(x,y)\n                    item.setTextAlignment(Qt.AlignCenter)\n                else:\n                    pass\n        self.settext(&#39;将文字居中显示&#39;)  \n\n    def cellchange(self,row,col):\n        item = self.table.item(row,col)\n        txt = item.text()\n        self.settext(&#39;第%s行，第%s列 , 数据改变为:%s&#39;%(row,col,txt))\n\n    def g_info(self):\n        # 我们每次使用这个功能时先把全变量原始进程列表 -- original_processes --清空好吧\n        original_processes = []\n        row = self.table.rowCount()\n\n        for j in range(row):                            # 有几行就有几个进程\n            na = self.table.item(j,2).text()\n            at = int(self.table.item(j,3).text())\n            st = int(self.table.item(j,4).text())\n            sc = int(self.table.item(j,5).text())\n            p = Process(na, at, st, sc)\n            original_processes.append(p)\n            print(na+&#39; &#39;+str(at)+&#39; &#39;+str(st)+&#39; &#39;+str(sc))\n\n        &#39;&#39;&#39;\n        由于第一个进程不一定就是到达时间最短的进程，所以我们先按照\n        到达时间给进程排个序\n        &#39;&#39;&#39;\n        _sorted_processes = original_processes[:]\n        _sorted_processes.sort(key=operator.attrgetter(&#39;arrive_time&#39;))\n\n        infor_list = fcfs(_sorted_processes)\n        self.avrtime_edit.setText(str(infor_list[1]))\n        self.over_Edit.setText(str(infor_list[0]))\n        self.settext(&#39;获取表格信息，生成调度序列，计算平均、平均带权周转时间，并显示&#39;)\n\n    def settext(self,txt):\n        font = QFont(&#39;微软雅黑&#39;,10)\n        self.txt.setFont(font)\n        self.txt.setText(txt)  \n\n\nif __name__ == &#39;__main__&#39;:\n    app = QApplication(sys.argv)\n    ui = ui()\n    sys.exit(app.exec_())\n</code></pre>\n<h2 id=\"h2-u5927u4F53u601Du8DEF\"><a name=\"大体思路\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>大体思路</h2><h4 id=\"h4-u6570u636Eu7ED3u6784u5B9Au4E49u53CAu529Fu80FDu7B97u6CD5u90E8u5206\"><a name=\"数据结构定义及功能算法部分\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>数据结构定义及功能算法部分</h4><pre><code class=\"lang-python\">#  引入数据结构\n# 定义每个进程基本数据结构\nclass Process:\n    def __init__(self, name, arrive_time, serve_time, static_class, ready=False, over=False):\n        self.name = name                                    # 进程名称\n        self.arrive_time = arrive_time                      # 到达时间\n        self.serve_time = serve_time                        # 服务时间\n        self.left_serve_time = serve_time                   # 剩余需要服务的时间\n        self.finish_time = 0                                # 完成时间\n        self.cycling_time = 0                               # 周转时间\n        self.w_cycling_time = 0                             # 带权周转时间\n        self.response_ratio = 0                             # 响应比\n        self.pre_queue = 0                                  # 定义现在所在的队列\n        self.pre_queue_tb = 0                               # 目前所在队列的时间片\n        self.used_time = 0                                  # 已经使用的时间，也就是（服务时间 - 剩余服务时间）\n        self.ready = ready                                  # 记录就绪状态\n        self.over = over                                    # 记录完成状态\n        self.static_class = static_class                    # 人为赋予静态优先级\n\n\n# 现来先服务作业调度算法\ndef fcfs(processes): # 到达时间小的优先\n\n    sum_cycling_time = 0\n    sum_w_cycling_time = 0\n    number = len(processes)\n    over_list = []\n    min_key = 0\n    fin_name = []\n    name_string = &#39;&#39;\n    time_string = &#39;带权周转时间：&#39;\n    last_infor = []\n    running_time = 0\n    while processes:\n        min = processes[0].arrive_time\n        for i in range(len(processes)):\n            if processes[i].arrive_time &lt;= min:\n                min = processes[i].arrive_time\n                min_key = i\n\n        running_time += processes[min_key].serve_time\n        processes[min_key].cycling_time = running_time - processes[min_key].arrive_time\n        processes[min_key].w_cycling_time = processes[min_key].cycling_time / processes[min_key].serve_time\n        sum_cycling_time += processes[min_key].cycling_time\n        sum_w_cycling_time += processes[min_key].w_cycling_time\n\n        over_list.append(processes.pop(min_key))\n    for i in range(len(over_list)):\n        print(over_list[i].name)\n        name_string += (over_list[i].name+&#39;   &#39;)\n        fin_name.append(over_list[i].name)\n\n    a_c_time = sum_cycling_time/number\n    a_w_c_time = sum_w_cycling_time/number\n    print(&#39;平均周转时间：&#39; + str(a_c_time))\n    print(&#39;平均带权周转时间：&#39; + str(a_w_c_time/number))\n    time_string += (str(a_c_time) + &#39;    平均带权周转时间：&#39; + str(a_w_c_time))\n\n    last_infor.append(name_string)\n    last_infor.append(time_string)\n    # return fin_name\n    return last_infor\n</code></pre>\n<p>这部分内容在之前的博客中有大体的讲，不过好像是重构了，过段时间应该还要重构。</p>\n<p>这里要注意返回的列表有两项，分别是调度完之后的作业or进程名称顺序字符串，还有平均周转时间和平均带权周转时间的时间参数字符串。就不多讲了。</p>\n<p>在每次执行完一个作业or进程之后，会进行一个周转时间和带权周转时间的计算，方便计算性能。</p>\n<p>其余和之前差不多。</p>\n<h4 id=\"h4-gui-\"><a name=\"GUI部分\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>GUI部分</h4><p>引入的库和模块</p>\n<pre><code class=\"lang-python\">from PyQt5.QtWidgets import (QWidget,QLineEdit,QHBoxLayout,QTableWidget,QPushButton,QApplication,QVBoxLayout,QTableWidgetItem,QCheckBox,QAbstractItemView,QHeaderView,QLabel,QFrame)\nfrom PyQt5 import QtWidgets, QtCore\nfrom PyQt5.QtCore import Qt\nfrom builtins import super, str, range\nfrom PyQt5.QtGui import QFont,QColor\nfrom faker import Factory\nimport random, sys, operator\n</code></pre>\n<p>主要用了是PyQt5的模块，另外加一些内置的计算模块，像后面的算法还用到numpy等科学计算模块</p>\n<p>语法、思路、排版、实现</p>\n<blockquote>\n<p>直接往代码里写了啊</p>\n</blockquote>\n<pre><code class=\"lang-python\">class ui(QWidget):                             # 继承QWidget\n    def __init__(self):\n        super(ui, self).__init__()\n        self.setupUI()\n        self.id = 1\n        self.lines = []\n        self.editable = True\n        self.des_sort = True\n        self.faker = Factory.create()            # faker库是数据伪造生成器，后续会搬运一篇博文讲\n\n        &#39;&#39;&#39;\n        这里面主要使用了 \n        按钮-button\n        标签-lable\n        编辑单行文本框-editline\n        表格-table\n        这几个控件\n        我觉得难点主要在于不熟悉这些控件的方法，英语又不好官方文档看明白是不可能的...对了6级第一次裸考没过\n        &#39;&#39;&#39;\n        # 按钮绑定事件 \n        &#39;&#39;&#39;\n        主要事件\n        add_line 表格添加行\n        del_line 表格删除行\n        modify_line 控制表格是否可以被编辑\n        middle 设置表格文字居中显示\n        cellchange 根据相关触发的操作提示你的操作是干嘛的\n        &#39;&#39;&#39;\n        self.btn_add.clicked.connect(self.add_line)\n        self.btn_del.clicked.connect(self.del_line)\n        self.btn_modify.clicked.connect(self.modify_line)\n        self.btn_set_middle.clicked.connect(self.middle)\n        self.btn_get_info.clicked.connect(self.g_info)\n\n        self.table.cellChanged.connect(self.cellchange)\n\n        global original_processes               # 这里我们定义全局变量 - 原始进程列表，是一个二维列表\n\n\n    def setupUI(self):\n        # 控件的排版，做的时候嵌套布局那一块觉得自己是真的学到了，很有趣，基本设置Google Baidu都可找到\n        self.setWindowTitle(&#39;数据测试&#39;)\n        self.resize(720,420)\n\n        self.table = QTableWidget(self)\n\n        self.btn_add = QPushButton(&#39;增加&#39;)\n        self.btn_del = QPushButton(&#39;删除&#39;)\n        self.btn_modify = QPushButton(&#39;可以编辑&#39;)\n        self.btn_set_middle = QPushButton(&#39;文字居中&#39;)\n        self.btn_get_info = QPushButton(&#39;生成调度序列&#39;)\n\n        # 弹簧控件，这个不是很明白\n        self.spacerItem = QtWidgets.QSpacerItem(20, 20, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)\n\n        # 垂直布局，使用嵌套布局方式\n        # 我们把所有按钮按照盒布局-垂直布局方式，构成嵌套布局的一个块\n        # 按照设置的方式依此从上到下\n        self.vbox = QVBoxLayout()\n        self.vbox.addWidget(self.btn_add)\n        self.vbox.addWidget(self.btn_del)\n        self.vbox.addWidget(self.btn_modify)\n        self.vbox.addWidget(self.btn_set_middle)\n        self.vbox.addWidget(self.btn_get_info)\n        self.vbox.addSpacerItem(self.spacerItem)            \n\n        self.txt = QLabel()                             # 这是进行操作时显示在最左下角的提示信息\n        self.txt.setMinimumHeight(50)                   # 限定控件大小\n\n        self.lab_over = QLabel(&#39;调度顺序&#39;)               # 输出队列顺序\n        self.lab_over.setMinimumHeight(20)\n        self.over_Edit = QLineEdit(self)\n        self.over_Edit.setMinimumHeight(25)\n\n        self.lab_time = QLabel(&#39;平均周转时间和平均带权周转时间&#39;)\n        self.avrtime_edit = QLineEdit(self)\n\n        # 垂直布局\n        # 把表格和下面的操作提示文本信息按照垂直布局设置，作为嵌套布局方式的另一部分\n        self.vbox2 = QVBoxLayout()                          \n        self.vbox2.addWidget(self.table)                    # 将表格和下面的操作提示放入垂直布局，先放表格\n        self.vbox2.addWidget(self.lab_over)                 # 放输出队列\n        self.vbox2.addWidget(self.over_Edit)\n        self.vbox2.addWidget(self.lab_time)\n        self.vbox2.addWidget(self.avrtime_edit)\n\n        self.vbox2.addWidget(self.txt)                      # 再放文本框\n\n        # 水平布局\n        # 这是将上述两个布局方式作为整体布局的元素，vbox和vbox2共同放入水平布局\n        self.hbox = QHBoxLayout()                          \n        self.hbox.addLayout(self.vbox2)                     # 将这样就会自左向右，先放表格，\n        self.hbox.addLayout(self.vbox)                      # 再放按钮\n\n        # 将水平布局放入总体布局\n        self.setLayout(self.hbox)\n\n        # 表格基本属性设置   \n        self.table.setColumnCount(6)                                    # 设置列数\n        self.table.horizontalHeader().setDefaultAlignment(QtCore.Qt.AlignCenter)\n        self.headers = [&#39;ID&#39;,&#39;选择&#39;,&#39;进程名&#39;, &#39;到达时间&#39;, &#39;服务时间&#39;, &#39;静态优先级&#39;]      # 设置每列标题\n        self.table.setHorizontalHeaderLabels(self.headers)              # 导入\n        self.table.verticalHeader().setVisible(False)                   # 隐藏垂直表头\n        self.show()\n\n    # 添加行\n    def add_line(self):\n        self.table.cellChanged.disconnect()\n        row = self.table.rowCount()                                     # 获取目前所有行的数量\n        self.table.setRowCount(row + 1)\n        id = str(self.id)\n\n        # 生成复选框， 并设置居中显示\n        ck = QCheckBox()\n        h = QHBoxLayout()\n        h.setAlignment(Qt.AlignCenter)\n        h.addWidget(ck)\n        w = QWidget()\n        w.setLayout(h)\n\n        # 变量由faker自动生成\n        name = self.faker.name()\n        arr_time = str(random.randint(0,9))\n        ser_time = str(random.randint(0,9))\n        sta_class = str(random.randint(0,9))\n\n        # 设置新建行的数据\n        self.table.setItem(row,0,QTableWidgetItem(id))\n        self.table.setCellWidget(row,1,w)\n        self.table.setItem(row,2,QTableWidgetItem(name))\n        self.table.setItem(row,3,QTableWidgetItem(arr_time))\n        self.table.setItem(row,4,QTableWidgetItem(ser_time))\n        self.table.setItem(row,5,QTableWidgetItem(sta_class))\n\n        self.id += 1                                                        # 设置完不要忘记id加一\n        self.lines.append([id,ck,name,arr_time,ser_time,sta_class])\n        self.settext(&#39;自动生成随机一行数据！,checkbox设置为居中显示&#39;)\n        self.table.cellChanged.connect(self.cellchange)\n\n    # 删除行\n    def del_line(self):\n        removeline = []\n        for line in self.lines:\n            if line[1].isChecked():\n                row = self.table.rowCount()\n                for x in range(row,0,-1):\n                    if line[0] == self.table.item(x - 1,0).text():\n                        self.table.removeRow(x - 1)\n                        removeline.append(line)\n        for line in removeline:\n            self.lines.remove(line)\n        self.settext(&#39;删除checkbox中选中状态的行&#39;)\n\n    def modify_line(self):\n        if self.editable == True:\n            self.table.setEditTriggers(QAbstractItemView.NoEditTriggers)\n            self.btn_modify.setText(&#39;禁止编辑&#39;)\n            self.editable = False\n        else:\n            self.table.setEditTriggers(QAbstractItemView.AllEditTriggers)\n            self.btn_modify.setText(&#39;可以编辑&#39;)\n            self.editable = True\n        self.settext(&#39;设置是否可以编辑表格信息&#39;)\n\n    def middle(self):\n        row = self.table.rowCount()\n        for x in range(row):\n            for y in range(6):\n                if y != 1:\n                    item = self.table.item(x,y)\n                    item.setTextAlignment(Qt.AlignCenter)\n                else:\n                    pass\n        self.settext(&#39;将文字居中显示&#39;)  \n\n    def cellchange(self,row,col):\n        item = self.table.item(row,col)\n        txt = item.text()\n        self.settext(&#39;第%s行，第%s列 , 数据改变为:%s&#39;%(row,col,txt))\n\n    def g_info(self):\n        # 我们每次使用这个功能时先把全变量原始进程列表 -- original_processes --清空好吧\n        # 这个函数获取表格数据存入队列，初始化进程信息加入列表，最后调主算法函数进行模拟调度，最后返回信息\n        original_processes = []\n        row = self.table.rowCount()\n\n        for j in range(row):                            # 有几行就有几个进程\n            na = self.table.item(j,2).text()\n            at = int(self.table.item(j,3).text())\n            st = int(self.table.item(j,4).text())\n            sc = int(self.table.item(j,5).text())\n            p = Process(na, at, st, sc)\n            original_processes.append(p)\n            print(na+&#39; &#39;+str(at)+&#39; &#39;+str(st)+&#39; &#39;+str(sc))\n\n        &#39;&#39;&#39;\n        由于第一个进程不一定就是到达时间最短的进程，所以我们先按照\n        到达时间给进程排个序\n        这是后来才想到的，还有很多诸如此类的bug...脑壳疼\n        &#39;&#39;&#39;\n        _sorted_processes = original_processes[:]\n        _sorted_processes.sort(key=operator.attrgetter(&#39;arrive_time&#39;))\n\n        infor_list = fcfs(_sorted_processes)\n        # 讲返回的信息填入文本框\n        self.avrtime_edit.setText(str(infor_list[1]))\n        self.over_Edit.setText(str(infor_list[0]))\n        self.settext(&#39;获取表格信息，生成调度序列，计算平均、平均带权周转时间，并显示&#39;)\n    # 提示字体的设置\n    def settext(self,txt):\n        font = QFont(&#39;微软雅黑&#39;,10)\n        self.txt.setFont(font)\n        self.txt.setText(txt)\n</code></pre>\n<p>最后就…</p>\n<pre><code class=\"lang-python\">if __name__ == &#39;__main__&#39;:\n    app = QApplication(sys.argv)\n    ui = ui()\n    sys.exit(app.exec_())\n</code></pre>\n<blockquote>\n<p>大体框架写完之后觉得好多东西并没有那么难，只是你没有见过所以觉得很唬人，然而我觉得我coding效率还是太低了，诶</p>\n</blockquote>\n<h2 id=\"h2-u6F14u793A\"><a name=\"演示\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>演示</h2><ul>\n<li><p>主页面</p>\n<p><img src=\"https://i.loli.net/2019/03/13/5c87d832bdbec.png\" alt=\"\"></p>\n</li><li><p>添加行并自动生成数据</p>\n<p><img src=\"https://i.loli.net/2019/03/13/5c87d8c84a5f1.png\" alt=\"\"></p>\n</li><li><p>更改数据</p>\n<p><img src=\"https://i.loli.net/2019/03/13/5c87d8d775837.png\" alt=\"\"></p>\n</li><li><p>居中对齐</p>\n<p><img src=\"https://i.loli.net/2019/03/13/5c87d8eb66d3b.png\" alt=\"\"></p>\n</li><li><p>生成序列并显示调度顺序和时间效率</p>\n<p><img src=\"https://i.loli.net/2019/03/13/5c87d91dca9a2.png\" alt=\"\"></p>\n</li><li><p>删除选中行</p>\n<p><img src=\"https://i.loli.net/2019/03/13/5c87d935206e1.png\" alt=\"\"></p>\n<p><img src=\"https://i.loli.net/2019/03/13/5c87d93f9b163.png\" alt=\"\"></p>\n<blockquote>\n<p>完事了就，太简陋···但是一想这东西用c/c++写就也太麻烦了吧，python真好~</p>\n</blockquote>\n</li></ul>\n<h2 id=\"h2-u4E0Du8DB3u4E0Eu6539u8FDBu601Du8DEF\"><a name=\"不足与改进思路\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>不足与改进思路</h2><h4 id=\"h4-u4E0Du8DB3\"><a name=\"不足\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>不足</h4><ul>\n<li>算法有问题，数据容错率极低，经常因为数据不规范就原地崩</li><li>没有实现 作业/进程 数据可从外部导入的功能</li><li>没实现 单步执行 的功能，我想这是最要紧的…</li><li>没有 相同进程不同算法性能数据比较 功能</li><li>不够集成</li></ul>\n<p>总体看来，就是只实现了一个大体的demo，还有很多需要改进</p>\n<h4 id=\"h4-u6539u8FDBu601Du8DEF\"><a name=\"改进思路\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>改进思路</h4><ul>\n<li>算法重构，昨天调的时候觉得太乱了，而且如果要单步执行的话目前算法应该不能达到要求</li><li>优化GUI</li><li>还是算法吧，数据容错性太差</li><li>添加从外部文件导入数据功能</li></ul>\n<blockquote>\n<p>题外话：最近有些焦虑，铺天盖地的说2019计算机考研哪哪都炸，初试神仙打架复试百里挑一，985211各路神仙跨考计算机的数不过来，感觉350都不叫分了。就一股脑都来吃计算机这碗饭，就连调剂的生源都不错，更何况一堆搞ACM的、手里拿着一大堆项目、顶级论文发了好几篇的神仙也…越来越觉得路难走，实力又真是差十万八千里，就越发急于求成，想很快可以出成绩看到结果。输在了起跑线上在后面得付出更多的努力，然而更多时候只是停留嘴面实际行动又不及十分之一。可能就不具备那种潜质再者说没有足够的动力一直激励自己。但，但行好事莫问前程吧。今天20了…真快，可以再加把劲</p>\n<p>写的太晚了难免有纰漏，望海涵</p>\n</blockquote>\n<p><a href=\"https://github.com/lizonglin313/-python-\">源码地址</a></p>\n', '2020-07-21', '2020-07-21', '0');
INSERT INTO `article_info` VALUES ('74', '以太坊私链搭建', '58', '> 很多时候，在开发中我们需要使用私有链进行测试。\n>\n> 本文主要讲述如何在Ubuntu系统中使用以太坊虚拟环境搭建私有链。\n\n## Geth（go-ethereum客户端）\n\n首先，我们需要安装 geth 。具体安装参考[官方指南](<https://github.com/ethereum/Go-ethereum/wiki/Building-Ethereum>)\n\n打开终端，分别输入以下命令：\n\n```java\nsudo apt-get installsoftware-properties-common\n\nsudo add-apt-repository -yppa:ethereum/ethereum\n\nsudo add-apt-repository -yppa:ethereum/ethereum-dev\n\nsudo apt-get update\n\nsudo apt-get install ethereum\n```\n\n安装过程中如果出错，就要去看官方安装指南，可能缺少某些组件，这样就需要我们先安装所需要的组件。\n\n安装完成后，输入 geth ,如果现实出命令行各种参数提示信息，则说明安装成功。\n\n## 搭建私有链\n\n> 以太坊支持自定义区块。我们需要定义自己的创世区块作为首节点。\n\n### 创世区块\n\n创世区块的信息写在一个json格式的配置文件中。首先将下面的内容保存成一个json文件，例如 genesis.json 。\n\n文件内容如下：\n\n```json\n{\n  \"config\": {\n        \"chainId\": 10, \n        \"homesteadBlock\": 0,\n        \"eip155Block\": 0,\n        \"eip158Block\": 0\n    },\n  \"alloc\"      : {},\n  \"coinbase\"   : \"0x0000000000000000000000000000000000000000\",\n  \"difficulty\" : \"0x20000\",\n  \"extraData\"  : \"\",\n  \"gasLimit\"   : \"0x2fefd8\",\n  \"nonce\"      : \"0x0000000000000042\",\n  \"mixhash\"    : \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n  \"parentHash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n  \"timestamp\"  : \"0x00\"\n}\n```\n\n### 写入创世区块\n\n我们先建一个名叫 privatechain 的文件夹，用来存储所有私链的所需要的信息。然后在把 genesis.json 文件放入此文件夹。我们还需要在 privatechain 文件夹中创建一个名叫 data0 的文件夹来存放区块链的数据，这个文件夹就相当于一个根节点。当我们基于genesis.json生成根节点后，其他人就可以来连接此根节点，从而能进行交易)。\n\n接下来进入 privatechain 目录下，执行初始化命令：\n\n```json\ncd privatechain\ngeth --datadir data0 init genesis.json\n```\n\n上面的命令的主体是 geth init，表示初始化区块链，命令可以带有选项和参数，其中 --datadir 选项后面跟一个目录名，这里为 data0，表示指定数据存放目录为 data0， genesis.json 是 init 命令的参数。\n\n![](https://i.loli.net/2019/04/20/5cbaddc62792e.png)\n\n运行上面的命令，会读取 genesis.json 文件，根据其中的内容，将创世区块写入到区块链中。如果看到信息中含有`Successfully wrote genesis state`字样，说明初始化成功。\n\n![](https://i.loli.net/2019/04/20/5cbaddff4bb62.png)\n\n这时，我们查看一下 privatechain 的目录结构：\n\n![](https://i.loli.net/2019/04/20/5cbade323454d.png)\n\n其中 geth/chaindata 中存放的是区块数据，keystore中存放的是账户数据。\n\n### 启动私有节点\n\n初始化完成后，就有了一条自己的私有链，之后就可以启动自己的私有链节点并做一些操作，在终端中输入以下命令即可启动节点：\n\n```\ngeth --datadir data0 --networkid 1108 console\n```\n\n上面命令的主体是 geth console，表示启动节点并进入交互式控制台 --datadir 选项指定使用 data0 作为数据目录，            --networkid 选项后面跟一个数字，这里是1108，表示指定这个私有链的网络id为1108。网络id在连接到其他节点的时候会用到，以太坊公网的网络id是1，为了不与公有链网络冲突，运行私有链节点的时候要指定自己的网络id(上面命令可能会运行失败，直接重启，再进入到privatechain目录中)。\n\n运行上面的命令后，就启动了区块链节点并进入了Javascript Console：\n\n![](https://i.loli.net/2019/04/20/5cbadf022427a.png)\n\n这是一个交互式的Javascript执行环境，在这里面可以执行Javascript代码，其中>是命令提示符。在这个环境里也内置了一些用来操作以太坊的Javascript对象，可以直接使用这些对象。这些对象主要包括：\n\n```python\neth：包含一些跟操作区块链相关的方法\nnet：包含以下查看p2p网络状态的方法\nadmin：包含一些与管理节点相关的方法\nminer：包含启动&停止挖矿的一些方法\npersonal：主要包含一些管理账户的方法\ntxpool：包含一些查看交易内存池的方法\nweb3：包含了以上对象，还包含一些单位换算的方法\n```\n\n### 使用Javascript Console\n\n进入以太坊Javascript Console后，就可以使用里面的内置对象做一些操作，这些内置对象提供的功能很丰富，比如查看区块和交易、创建账户、挖矿、发送交易、部署智能合约等。接下来介绍几个常用功能，下面的操作中，前面带>的表示在Javascript Console中执行的命令。\n\n#### 创建账户\n\n前面只是搭建了私有链，并没有自己的账户，可以在js console中输入eth.accounts来验证：\n\n```\n> eth.accounts\n[]\n```\n\n![](https://i.loli.net/2019/04/20/5cbadf7de70ab.png)\n\n此时没有账户，接下来使用personal对象来创建一个账户：\n\n```\n> personal.newAccount()\n> Passphrase:\n> Repeat passphrase:\n```\n\n![](https://i.loli.net/2019/04/20/5cbadfb5980fb.png)\n\nPassphrase其实就是密码的意思，输入两次密码后，就创建了一个账户。再次执行命令，这时候再去看账户，就有两个了:\n\n```\n> eth.accounts\n```\n\n![](https://i.loli.net/2019/04/20/5cbadfe7eb096.png)\n\n账户默认会保存在数据目录的 keystore 文件夹中。查看目录结构，发现 data0/keystore 中多了两个文件，这两个文件就对应刚才创建的两个账户，这是json格式的文本文件，可以打开查看，里面存的是私钥经过密码加密后的信息。\n\n![](https://i.loli.net/2019/04/20/5cbae01f2a4d9.png)\n\n#### 查看账户余额\n\neth对象提供了查看账户余额的方法：\n\n```\n> eth.getBalance(eth.accounts[0])\n0\n> eth.getBalance(eth.accounts[1])\n0\n```\n\n![](https://i.loli.net/2019/04/20/5cbae04fe320a.png)\n\n目前两个账户的以太币余额都是0，要使账户有余额，可以从其他账户转账过来，或者通过挖矿来获得以太币奖励。\n\n#### 启动，停止挖矿\n\n通过miner.start()来启动挖矿：\n\n```\n> miner.start(10)\n```\n\n其中start的参数表示挖矿使用的线程数。第一次启动挖矿会先生成挖矿所需的DAG文件，这个过程有点慢，等进度达到100%后，就会开始挖矿，此时屏幕会被挖矿信息刷屏。\n\n图中percentage表示进度，进度达到100%开始挖矿。\n\n![](https://i.loli.net/2019/04/20/5cbae0c0e1192.png)\n\n出现小锤子即为挖到了。\n\n![](https://i.loli.net/2019/04/20/5cbae0ddd116e.png)\n\n如果想停止挖矿，并且进度已经达到100%之后，可以在输入：\n\n```\n> miner.stop()：\n```\n\n注意：输入的字符会被挖矿刷屏信息冲掉，没有关系，只要输入完整的miner.stop()之后回车，即可停止挖矿。\n\n挖到一个区块会奖励5个以太币，挖矿所得的奖励会进入矿工的账户，这个账户叫做 coinbase。\n\n- 默认情况下 coinbase 是本地账户中的第一个账户，现在的coinbase是账户0\n- 要想使挖矿奖励进入其他账户，通过miner.setEtherbase()将其他账户设置成coinbase即可\n- 挖到区块以后，账户0里面应该就有余额了，用getBalance()查看，其返回值的单位是 wei，wei 是以太币的最小单位，1个以太币=10的18次方个 wei。要查看有多少个以太币，可以用web3.fromWei()将返回值换算成以太币\n\n```\n> eth.coinbase\n> miner.setEtherbase(eth.accounts[1])\n> web3.fromWei(eth.getBalance(eth.accounts[0]),\'ether\')\n```\n\n![](https://i.loli.net/2019/04/20/5cbae176ab242.png)\n\n#### 发送交易\n\n截止目前，账户1的余额还是0：\n\n```\n> eth.getBalance(eth.accounts[1])\n0\n```\n\n可以通过发送一笔交易，从账户0转移10个以太币到账户1：\n\n- 这里需要注意的是，账户每隔一段时间就会被锁住，要发送交易，必须先解锁账户，由于我们要从账户0发送交易，所以要解锁账户0，输入创建账户时设置的密码，就可以成功解锁账户。\n\n```\n> personal.unlockAccount(eth.accounts[0])\nUnlock account 0x4a3b0216e1644c1bbabda527a6da7fc5d178b58f\nPassphrase: \ntrue\n```\n\n然后我们发送交易：\n\n```\n> amount = web3.toWei(10,\'ether\')\n\"10000000000000000000\"\n> eth.sendTransaction({from:eth.accounts[0],to:eth.accounts[1],value:amount})\n```\n\n我们去查看账户1中的余额：\n\n```\n> eth.getBalance(eth.accounts[1])\n0\n```\n\n发现还没转过去，此时交易已经提交到区块链，但还未被处理，这可以通过查看txpool来验证：\n\n```\n> txpool.status\n{\n  pending: 1,\n  queued: 0\n}\n```\n\n其中有一条pending的交易，pending表示已提交但还未被处理的交易。\n\n![](https://i.loli.net/2019/04/20/5cbae2846d1a7.png)\n\n要使交易被处理，必须要挖矿。这里我们启动挖矿，然后等待挖到一个区块之后就停止挖矿：\n\n```\n> miner.start(1);admin.sleepBlocks(1);miner.stop();\n```\n\n当miner.stop()返回true后，txpool中pending的交易数量应该为0了，说明交易已经被处理了，而账户1应该收到币了：\n\n```\n> web3.fromWei(eth.getBalance(eth.accounts[1]),\'ether\')\n10\n```\n\n![](https://i.loli.net/2019/04/20/5cbae3a8852c5.png)\n\n#### 查看交易和区块\n\neth对象封装了查看交易和区块信息的方法。\n\n查看当前区块总数：\n\n```\n> eth.blockNumber\n```\n\n通过区块号查看区块：\n\n```\n> eth.getBlock(66)\n```\n\n![](https://i.loli.net/2019/04/20/5cbae3e4e7b9f.png)\n\n至此，私链搭建工作就基本完成了。\n\n> ### 参考\n>\n>  [LBC-Team](<https://learnblockchain.cn/2018/03/18/create_private_blockchain/>)\n>\n> [柠檬宵宵-区块链学习（三）](<https://blog.csdn.net/striver_jt/article/details/68490921>)', '<blockquote>\n<p>很多时候，在开发中我们需要使用私有链进行测试。</p>\n<p>本文主要讲述如何在Ubuntu系统中使用以太坊虚拟环境搭建私有链。</p>\n</blockquote>\n<h2 id=\"h2-geth-go-ethereum-\"><a name=\"Geth（go-ethereum客户端）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Geth（go-ethereum客户端）</h2><p>首先，我们需要安装 geth 。具体安装参考<a href=\"https://github.com/ethereum/Go-ethereum/wiki/Building-Ethereum\">官方指南</a></p>\n<p>打开终端，分别输入以下命令：</p>\n<pre><code class=\"lang-java\">sudo apt-get installsoftware-properties-common\n\nsudo add-apt-repository -yppa:ethereum/ethereum\n\nsudo add-apt-repository -yppa:ethereum/ethereum-dev\n\nsudo apt-get update\n\nsudo apt-get install ethereum\n</code></pre>\n<p>安装过程中如果出错，就要去看官方安装指南，可能缺少某些组件，这样就需要我们先安装所需要的组件。</p>\n<p>安装完成后，输入 geth ,如果现实出命令行各种参数提示信息，则说明安装成功。</p>\n<h2 id=\"h2-u642Du5EFAu79C1u6709u94FE\"><a name=\"搭建私有链\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>搭建私有链</h2><blockquote>\n<p>以太坊支持自定义区块。我们需要定义自己的创世区块作为首节点。</p>\n</blockquote>\n<h3 id=\"h3-u521Bu4E16u533Au5757\"><a name=\"创世区块\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>创世区块</h3><p>创世区块的信息写在一个json格式的配置文件中。首先将下面的内容保存成一个json文件，例如 genesis.json 。</p>\n<p>文件内容如下：</p>\n<pre><code class=\"lang-json\">{\n  &quot;config&quot;: {\n        &quot;chainId&quot;: 10, \n        &quot;homesteadBlock&quot;: 0,\n        &quot;eip155Block&quot;: 0,\n        &quot;eip158Block&quot;: 0\n    },\n  &quot;alloc&quot;      : {},\n  &quot;coinbase&quot;   : &quot;0x0000000000000000000000000000000000000000&quot;,\n  &quot;difficulty&quot; : &quot;0x20000&quot;,\n  &quot;extraData&quot;  : &quot;&quot;,\n  &quot;gasLimit&quot;   : &quot;0x2fefd8&quot;,\n  &quot;nonce&quot;      : &quot;0x0000000000000042&quot;,\n  &quot;mixhash&quot;    : &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,\n  &quot;parentHash&quot; : &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,\n  &quot;timestamp&quot;  : &quot;0x00&quot;\n}\n</code></pre>\n<h3 id=\"h3-u5199u5165u521Bu4E16u533Au5757\"><a name=\"写入创世区块\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>写入创世区块</h3><p>我们先建一个名叫 privatechain 的文件夹，用来存储所有私链的所需要的信息。然后在把 genesis.json 文件放入此文件夹。我们还需要在 privatechain 文件夹中创建一个名叫 data0 的文件夹来存放区块链的数据，这个文件夹就相当于一个根节点。当我们基于genesis.json生成根节点后，其他人就可以来连接此根节点，从而能进行交易)。</p>\n<p>接下来进入 privatechain 目录下，执行初始化命令：</p>\n<pre><code class=\"lang-json\">cd privatechain\ngeth --datadir data0 init genesis.json\n</code></pre>\n<p>上面的命令的主体是 geth init，表示初始化区块链，命令可以带有选项和参数，其中 —datadir 选项后面跟一个目录名，这里为 data0，表示指定数据存放目录为 data0， genesis.json 是 init 命令的参数。</p>\n<p><img src=\"https://i.loli.net/2019/04/20/5cbaddc62792e.png\" alt=\"\"></p>\n<p>运行上面的命令，会读取 genesis.json 文件，根据其中的内容，将创世区块写入到区块链中。如果看到信息中含有<code>Successfully wrote genesis state</code>字样，说明初始化成功。</p>\n<p><img src=\"https://i.loli.net/2019/04/20/5cbaddff4bb62.png\" alt=\"\"></p>\n<p>这时，我们查看一下 privatechain 的目录结构：</p>\n<p><img src=\"https://i.loli.net/2019/04/20/5cbade323454d.png\" alt=\"\"></p>\n<p>其中 geth/chaindata 中存放的是区块数据，keystore中存放的是账户数据。</p>\n<h3 id=\"h3-u542Fu52A8u79C1u6709u8282u70B9\"><a name=\"启动私有节点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>启动私有节点</h3><p>初始化完成后，就有了一条自己的私有链，之后就可以启动自己的私有链节点并做一些操作，在终端中输入以下命令即可启动节点：</p>\n<pre><code>geth --datadir data0 --networkid 1108 console\n</code></pre><p>上面命令的主体是 geth console，表示启动节点并进入交互式控制台 —datadir 选项指定使用 data0 作为数据目录，            —networkid 选项后面跟一个数字，这里是1108，表示指定这个私有链的网络id为1108。网络id在连接到其他节点的时候会用到，以太坊公网的网络id是1，为了不与公有链网络冲突，运行私有链节点的时候要指定自己的网络id(上面命令可能会运行失败，直接重启，再进入到privatechain目录中)。</p>\n<p>运行上面的命令后，就启动了区块链节点并进入了Javascript Console：</p>\n<p><img src=\"https://i.loli.net/2019/04/20/5cbadf022427a.png\" alt=\"\"></p>\n<p>这是一个交互式的Javascript执行环境，在这里面可以执行Javascript代码，其中&gt;是命令提示符。在这个环境里也内置了一些用来操作以太坊的Javascript对象，可以直接使用这些对象。这些对象主要包括：</p>\n<pre><code class=\"lang-python\">eth：包含一些跟操作区块链相关的方法\nnet：包含以下查看p2p网络状态的方法\nadmin：包含一些与管理节点相关的方法\nminer：包含启动&amp;停止挖矿的一些方法\npersonal：主要包含一些管理账户的方法\ntxpool：包含一些查看交易内存池的方法\nweb3：包含了以上对象，还包含一些单位换算的方法\n</code></pre>\n<h3 id=\"h3--javascript-console\"><a name=\"使用Javascript Console\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>使用Javascript Console</h3><p>进入以太坊Javascript Console后，就可以使用里面的内置对象做一些操作，这些内置对象提供的功能很丰富，比如查看区块和交易、创建账户、挖矿、发送交易、部署智能合约等。接下来介绍几个常用功能，下面的操作中，前面带&gt;的表示在Javascript Console中执行的命令。</p>\n<h4 id=\"h4-u521Bu5EFAu8D26u6237\"><a name=\"创建账户\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>创建账户</h4><p>前面只是搭建了私有链，并没有自己的账户，可以在js console中输入eth.accounts来验证：</p>\n<pre><code>&gt; eth.accounts\n[]\n</code></pre><p><img src=\"https://i.loli.net/2019/04/20/5cbadf7de70ab.png\" alt=\"\"></p>\n<p>此时没有账户，接下来使用personal对象来创建一个账户：</p>\n<pre><code>&gt; personal.newAccount()\n&gt; Passphrase:\n&gt; Repeat passphrase:\n</code></pre><p><img src=\"https://i.loli.net/2019/04/20/5cbadfb5980fb.png\" alt=\"\"></p>\n<p>Passphrase其实就是密码的意思，输入两次密码后，就创建了一个账户。再次执行命令，这时候再去看账户，就有两个了:</p>\n<pre><code>&gt; eth.accounts\n</code></pre><p><img src=\"https://i.loli.net/2019/04/20/5cbadfe7eb096.png\" alt=\"\"></p>\n<p>账户默认会保存在数据目录的 keystore 文件夹中。查看目录结构，发现 data0/keystore 中多了两个文件，这两个文件就对应刚才创建的两个账户，这是json格式的文本文件，可以打开查看，里面存的是私钥经过密码加密后的信息。</p>\n<p><img src=\"https://i.loli.net/2019/04/20/5cbae01f2a4d9.png\" alt=\"\"></p>\n<h4 id=\"h4-u67E5u770Bu8D26u6237u4F59u989D\"><a name=\"查看账户余额\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>查看账户余额</h4><p>eth对象提供了查看账户余额的方法：</p>\n<pre><code>&gt; eth.getBalance(eth.accounts[0])\n0\n&gt; eth.getBalance(eth.accounts[1])\n0\n</code></pre><p><img src=\"https://i.loli.net/2019/04/20/5cbae04fe320a.png\" alt=\"\"></p>\n<p>目前两个账户的以太币余额都是0，要使账户有余额，可以从其他账户转账过来，或者通过挖矿来获得以太币奖励。</p>\n<h4 id=\"h4--\"><a name=\"启动，停止挖矿\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>启动，停止挖矿</h4><p>通过miner.start()来启动挖矿：</p>\n<pre><code>&gt; miner.start(10)\n</code></pre><p>其中start的参数表示挖矿使用的线程数。第一次启动挖矿会先生成挖矿所需的DAG文件，这个过程有点慢，等进度达到100%后，就会开始挖矿，此时屏幕会被挖矿信息刷屏。</p>\n<p>图中percentage表示进度，进度达到100%开始挖矿。</p>\n<p><img src=\"https://i.loli.net/2019/04/20/5cbae0c0e1192.png\" alt=\"\"></p>\n<p>出现小锤子即为挖到了。</p>\n<p><img src=\"https://i.loli.net/2019/04/20/5cbae0ddd116e.png\" alt=\"\"></p>\n<p>如果想停止挖矿，并且进度已经达到100%之后，可以在输入：</p>\n<pre><code>&gt; miner.stop()：\n</code></pre><p>注意：输入的字符会被挖矿刷屏信息冲掉，没有关系，只要输入完整的miner.stop()之后回车，即可停止挖矿。</p>\n<p>挖到一个区块会奖励5个以太币，挖矿所得的奖励会进入矿工的账户，这个账户叫做 coinbase。</p>\n<ul>\n<li>默认情况下 coinbase 是本地账户中的第一个账户，现在的coinbase是账户0</li><li>要想使挖矿奖励进入其他账户，通过miner.setEtherbase()将其他账户设置成coinbase即可</li><li>挖到区块以后，账户0里面应该就有余额了，用getBalance()查看，其返回值的单位是 wei，wei 是以太币的最小单位，1个以太币=10的18次方个 wei。要查看有多少个以太币，可以用web3.fromWei()将返回值换算成以太币</li></ul>\n<pre><code>&gt; eth.coinbase\n&gt; miner.setEtherbase(eth.accounts[1])\n&gt; web3.fromWei(eth.getBalance(eth.accounts[0]),&#39;ether&#39;)\n</code></pre><p><img src=\"https://i.loli.net/2019/04/20/5cbae176ab242.png\" alt=\"\"></p>\n<h4 id=\"h4-u53D1u9001u4EA4u6613\"><a name=\"发送交易\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>发送交易</h4><p>截止目前，账户1的余额还是0：</p>\n<pre><code>&gt; eth.getBalance(eth.accounts[1])\n0\n</code></pre><p>可以通过发送一笔交易，从账户0转移10个以太币到账户1：</p>\n<ul>\n<li>这里需要注意的是，账户每隔一段时间就会被锁住，要发送交易，必须先解锁账户，由于我们要从账户0发送交易，所以要解锁账户0，输入创建账户时设置的密码，就可以成功解锁账户。</li></ul>\n<pre><code>&gt; personal.unlockAccount(eth.accounts[0])\nUnlock account 0x4a3b0216e1644c1bbabda527a6da7fc5d178b58f\nPassphrase: \ntrue\n</code></pre><p>然后我们发送交易：</p>\n<pre><code>&gt; amount = web3.toWei(10,&#39;ether&#39;)\n&quot;10000000000000000000&quot;\n&gt; eth.sendTransaction({from:eth.accounts[0],to:eth.accounts[1],value:amount})\n</code></pre><p>我们去查看账户1中的余额：</p>\n<pre><code>&gt; eth.getBalance(eth.accounts[1])\n0\n</code></pre><p>发现还没转过去，此时交易已经提交到区块链，但还未被处理，这可以通过查看txpool来验证：</p>\n<pre><code>&gt; txpool.status\n{\n  pending: 1,\n  queued: 0\n}\n</code></pre><p>其中有一条pending的交易，pending表示已提交但还未被处理的交易。</p>\n<p><img src=\"https://i.loli.net/2019/04/20/5cbae2846d1a7.png\" alt=\"\"></p>\n<p>要使交易被处理，必须要挖矿。这里我们启动挖矿，然后等待挖到一个区块之后就停止挖矿：</p>\n<pre><code>&gt; miner.start(1);admin.sleepBlocks(1);miner.stop();\n</code></pre><p>当miner.stop()返回true后，txpool中pending的交易数量应该为0了，说明交易已经被处理了，而账户1应该收到币了：</p>\n<pre><code>&gt; web3.fromWei(eth.getBalance(eth.accounts[1]),&#39;ether&#39;)\n10\n</code></pre><p><img src=\"https://i.loli.net/2019/04/20/5cbae3a8852c5.png\" alt=\"\"></p>\n<h4 id=\"h4-u67E5u770Bu4EA4u6613u548Cu533Au5757\"><a name=\"查看交易和区块\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>查看交易和区块</h4><p>eth对象封装了查看交易和区块信息的方法。</p>\n<p>查看当前区块总数：</p>\n<pre><code>&gt; eth.blockNumber\n</code></pre><p>通过区块号查看区块：</p>\n<pre><code>&gt; eth.getBlock(66)\n</code></pre><p><img src=\"https://i.loli.net/2019/04/20/5cbae3e4e7b9f.png\" alt=\"\"></p>\n<p>至此，私链搭建工作就基本完成了。</p>\n<blockquote>\n<h3 id=\"h3-u53C2u8003\"><a name=\"参考\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>参考</h3><p> <a href=\"https://learnblockchain.cn/2018/03/18/create_private_blockchain/\">LBC-Team</a></p>\n<p><a href=\"https://blog.csdn.net/striver_jt/article/details/68490921\">柠檬宵宵-区块链学习（三）</a></p>\n</blockquote>\n', '2020-07-22', '2020-07-22', '0');
INSERT INTO `article_info` VALUES ('75', 'C++Vector笔记', '53', '> 整理自wiki、菜鸟教程、W3Cschool\n\n### 什么是Vector\n\n**Vector** 是[C++标准程序库](https://zh.wikipedia.org/wiki/C%2B%2B標準程式庫)中的一个[类](https://zh.wikipedia.org/wiki/类_(计算机科学))，可视为会自动扩展容量的数组，以循序(Sequential)的方式维护变量集合。vector的特色有支持随机存取，在集合尾端增删元素很快，但是在集合中间增删元素比较费时。vector是[C++标准程序库](https://zh.wikipedia.org/wiki/C%2B%2B標準程式庫)中的众多[容器](https://zh.wikipedia.org/wiki/容器_(資料類型))（*container*）之一。 vector以[模板](https://zh.wikipedia.org/wiki/模板_(C%2B%2B))(泛型)方式实现，可以保存任意类型的变量，包括用户自定义的数据类型，例如：它可以是放置整数（int）类型的 vector、也可以是放置字符串（string）类型的 vector、或者放置用户自定类别（user-defined class）的 vector。(from:wiki)\n\n向量（Vector）是一个封装了动态大小数组的顺序容器（Sequence Container）。跟任意其它类型容器一样，它能够存放各种类型的对象。可以简单的认为，向量是一个能够存放任意类型的动态数组。(from:runoob)\n\n在c++中，vector是一个十分有用的容器。它能够像容器一样存放各种类型的对象，简单地说，vector是一个能够存放任意类型的动态数组，能够增加和压缩数据。(from:w3cschool)\n\n### 特性\n\n- 顺序序列：顺序容器中的元素按照严格的线性顺序排序。可以通过元素在序列中的位置访问对应的元素。\n- 动态数组：支持对序列中的任意元素进行快速直接访问，甚至可以通过指针算述进行该操作。操供了在序列末尾相对快速地添加/删除元素的操作。\n- 内存分配器感知：容器使用一个内存分配器对象来动态地处理它的存储需求。\n\n> 注意⚠\n>\n> 1. 如果你要表示的向量长度较长（需要为向量内部保存很多数），容易导致内存泄漏，而且效率会很低；\n>\n> 2. Vector作为函数的参数或者返回值时，需要注意它的写法：\n>\n>    `double Distance(vector<int>&a, vector<int>&b)`\n\n### 使用方法\n\n#### 基本方法\n\n- 引入头文件\n\n```c++\n#include <vector>\n```\n\n- 创建vector对象\n\n```c++\nvector<int> vec;\n```\n\n- 在尾部插入一个元素\n\n```c++\nvec.push_back(a);\n```\n\n- 在尾部删除一个元素\n\n```c++\nvec.pop_back();\n```\n\n- 使用下标访问\n\n```c++\ncout << vec[0] << endl;\n```\n\n- 使用迭代器访问\n\n```c++\nvector<int>::iterator it;\nfor (it = vec.begin(); it != vec.end(); it++)\n    cout << *it << endl;\n```\n\n- 在第`i+1`个元素前插入`a`\n\n```c++\nvec.insert(vec.begin()+i,a);\n```\n\n- 删除第三个元素\n\n```c++\nvec.erase(vec.begin()+2);\n```\n\n- 删除区间`[i,j-1]`，区间从`0`开始\n\n```c++\nvec.erase(vec.begin()+i,vec.end()+j);\n```\n\n- 获取长度\n\n```c++\nvec.size();\n```\n\n- 清空\n\n```c++\nvec.clear();\n```\n\n- 逆序，需要引入头文件`#include<algorithm>`\n\n```c++\nreverse(vec.begin(),vec.end());\n```\n\n- 使用`sort`排序，需要引入头文件`#include<algorithm>`\n\n```c++\nsort(vec.begin(),vec.end());	// 默认升序\n\n/* 通过重写排序算法降序排列 */\nbool Comp(const int &a,const int &b)\n{\n    return a>b;\n}\nsort(vec.begin(),vec.end(),Comp);	// 调用\n```\n\n#### 二维数组定义\n\n方法1：\n\n```c++\n#include <string.h>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n    int N = 5, M = 6; \n    vector<vector<int>> obj(N); 	//定义二维动态数组大小5行 \n    for(int i = 0; i < obj.size(); i++)	//动态二维数组为5行6列，值全为0 \n    { \n        obj[i].resize(M);	\n        // resize()改变当前使用数据的大小，如果它比当前使用的大，者填充默认值 \n    } \n \n    for(int i = 0; i< obj.size(); i++)//输出二维动态数组 \n    {\n        for(int j = 0; j < obj[i].size(); j++)\n        {\n            cout << obj[i][j] << \" \";\n        }\n        cout << \"\\n\";\n    }\n    return 0;\n}\n```\n\n方法2：\n\n```c++\n#include <string.h>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n \nint main()\n{\n    int N = 5, M = 6; \n    vector<vector<int>> obj(N, vector<int>(M)); //定义二维动态数组5行6列 \n \n    for(int i = 0; i < obj.size(); i++)	//输出二维动态数组 \n    {\n        for(int j = 0; j < obj[i].size(); j++)\n        {\n            cout << obj[i][j] << \" \";\n        }\n        cout << \"\\n\";\n    }\n    return 0;\n}\n```\n\n#### 结构体类型元素\n\n>  注意⚠：结构体要定义为全局！\n\n```c++\n#include<stdio.h>  \n#include<algorithm>  \n#include<vector>  \n#include<iostream>  \nusing namespace std;  \ntypedef struct rect  \n{  \n    int id;  \n    int length;  \n    int width;  \n　　//对于向量元素是结构体的，可在结构体内部定义比较函数，下面按照id,length,width升序排序。  \n　　bool operator< (const rect &a)  const  \n    {  \n        if(id!=a.id)  \n            return id<a.id;  \n        else  \n        {  \n            if(length!=a.length)  \n                return length<a.length;  \n            else  \n                return width<a.width;  \n        }  \n    }  \n}Rect;  \nint main()  \n{  \n    vector<Rect> vec;  \n    Rect rect;  \n    rect.id=1;  \n    rect.length=2;  \n    rect.width=3;  \n    vec.push_back(rect);  \n    vector<Rect>::iterator it=vec.begin();  \n    cout<<(*it).id<<\' \'<<(*it).length<<\' \'<<(*it).width<<endl;      \nreturn 0;  \n}  \n```', '<blockquote>\n<p>整理自wiki、菜鸟教程、W3Cschool</p>\n</blockquote>\n<h3 id=\"h3--vector\"><a name=\"什么是Vector\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是Vector</h3><p><strong>Vector</strong> 是<a href=\"https://zh.wikipedia.org/wiki/C%2B%2B標準程式庫\">C++标准程序库</a>中的一个<a href=\"https://zh.wikipedia.org/wiki/类_(计算机科学\">类</a>)，可视为会自动扩展容量的数组，以循序(Sequential)的方式维护变量集合。vector的特色有支持随机存取，在集合尾端增删元素很快，但是在集合中间增删元素比较费时。vector是<a href=\"https://zh.wikipedia.org/wiki/C%2B%2B標準程式庫\">C++标准程序库</a>中的众多<a href=\"https://zh.wikipedia.org/wiki/容器_(資料類型\">容器</a>)（<em>container</em>）之一。 vector以<a href=\"https://zh.wikipedia.org/wiki/模板_(C%2B%2B\">模板</a>)(泛型)方式实现，可以保存任意类型的变量，包括用户自定义的数据类型，例如：它可以是放置整数（int）类型的 vector、也可以是放置字符串（string）类型的 vector、或者放置用户自定类别（user-defined class）的 vector。(from:wiki)</p>\n<p>向量（Vector）是一个封装了动态大小数组的顺序容器（Sequence Container）。跟任意其它类型容器一样，它能够存放各种类型的对象。可以简单的认为，向量是一个能够存放任意类型的动态数组。(from:runoob)</p>\n<p>在c++中，vector是一个十分有用的容器。它能够像容器一样存放各种类型的对象，简单地说，vector是一个能够存放任意类型的动态数组，能够增加和压缩数据。(from:w3cschool)</p>\n<h3 id=\"h3-u7279u6027\"><a name=\"特性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>特性</h3><ul>\n<li>顺序序列：顺序容器中的元素按照严格的线性顺序排序。可以通过元素在序列中的位置访问对应的元素。</li><li>动态数组：支持对序列中的任意元素进行快速直接访问，甚至可以通过指针算述进行该操作。操供了在序列末尾相对快速地添加/删除元素的操作。</li><li>内存分配器感知：容器使用一个内存分配器对象来动态地处理它的存储需求。</li></ul>\n<blockquote>\n<p>注意⚠</p>\n<ol>\n<li><p>如果你要表示的向量长度较长（需要为向量内部保存很多数），容易导致内存泄漏，而且效率会很低；</p>\n</li><li><p>Vector作为函数的参数或者返回值时，需要注意它的写法：</p>\n<p><code>double Distance(vector&lt;int&gt;&amp;a, vector&lt;int&gt;&amp;b)</code></p>\n</li></ol>\n</blockquote>\n<h3 id=\"h3-u4F7Fu7528u65B9u6CD5\"><a name=\"使用方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>使用方法</h3><h4 id=\"h4-u57FAu672Cu65B9u6CD5\"><a name=\"基本方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>基本方法</h4><ul>\n<li>引入头文件</li></ul>\n<pre><code class=\"lang-c++\">#include &lt;vector&gt;\n</code></pre>\n<ul>\n<li>创建vector对象</li></ul>\n<pre><code class=\"lang-c++\">vector&lt;int&gt; vec;\n</code></pre>\n<ul>\n<li>在尾部插入一个元素</li></ul>\n<pre><code class=\"lang-c++\">vec.push_back(a);\n</code></pre>\n<ul>\n<li>在尾部删除一个元素</li></ul>\n<pre><code class=\"lang-c++\">vec.pop_back();\n</code></pre>\n<ul>\n<li>使用下标访问</li></ul>\n<pre><code class=\"lang-c++\">cout &lt;&lt; vec[0] &lt;&lt; endl;\n</code></pre>\n<ul>\n<li>使用迭代器访问</li></ul>\n<pre><code class=\"lang-c++\">vector&lt;int&gt;::iterator it;\nfor (it = vec.begin(); it != vec.end(); it++)\n    cout &lt;&lt; *it &lt;&lt; endl;\n</code></pre>\n<ul>\n<li>在第<code>i+1</code>个元素前插入<code>a</code></li></ul>\n<pre><code class=\"lang-c++\">vec.insert(vec.begin()+i,a);\n</code></pre>\n<ul>\n<li>删除第三个元素</li></ul>\n<pre><code class=\"lang-c++\">vec.erase(vec.begin()+2);\n</code></pre>\n<ul>\n<li>删除区间<code>[i,j-1]</code>，区间从<code>0</code>开始</li></ul>\n<pre><code class=\"lang-c++\">vec.erase(vec.begin()+i,vec.end()+j);\n</code></pre>\n<ul>\n<li>获取长度</li></ul>\n<pre><code class=\"lang-c++\">vec.size();\n</code></pre>\n<ul>\n<li>清空</li></ul>\n<pre><code class=\"lang-c++\">vec.clear();\n</code></pre>\n<ul>\n<li>逆序，需要引入头文件<code>#include&lt;algorithm&gt;</code></li></ul>\n<pre><code class=\"lang-c++\">reverse(vec.begin(),vec.end());\n</code></pre>\n<ul>\n<li>使用<code>sort</code>排序，需要引入头文件<code>#include&lt;algorithm&gt;</code></li></ul>\n<pre><code class=\"lang-c++\">sort(vec.begin(),vec.end());    // 默认升序\n\n/* 通过重写排序算法降序排列 */\nbool Comp(const int &amp;a,const int &amp;b)\n{\n    return a&gt;b;\n}\nsort(vec.begin(),vec.end(),Comp);    // 调用\n</code></pre>\n<h4 id=\"h4-u4E8Cu7EF4u6570u7EC4u5B9Au4E49\"><a name=\"二维数组定义\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二维数组定义</h4><p>方法1：</p>\n<pre><code class=\"lang-c++\">#include &lt;string.h&gt;\n#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nint main()\n{\n    int N = 5, M = 6; \n    vector&lt;vector&lt;int&gt;&gt; obj(N);     //定义二维动态数组大小5行 \n    for(int i = 0; i &lt; obj.size(); i++)    //动态二维数组为5行6列，值全为0 \n    { \n        obj[i].resize(M);    \n        // resize()改变当前使用数据的大小，如果它比当前使用的大，者填充默认值 \n    } \n\n    for(int i = 0; i&lt; obj.size(); i++)//输出二维动态数组 \n    {\n        for(int j = 0; j &lt; obj[i].size(); j++)\n        {\n            cout &lt;&lt; obj[i][j] &lt;&lt; &quot; &quot;;\n        }\n        cout &lt;&lt; &quot;\\n&quot;;\n    }\n    return 0;\n}\n</code></pre>\n<p>方法2：</p>\n<pre><code class=\"lang-c++\">#include &lt;string.h&gt;\n#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nint main()\n{\n    int N = 5, M = 6; \n    vector&lt;vector&lt;int&gt;&gt; obj(N, vector&lt;int&gt;(M)); //定义二维动态数组5行6列 \n\n    for(int i = 0; i &lt; obj.size(); i++)    //输出二维动态数组 \n    {\n        for(int j = 0; j &lt; obj[i].size(); j++)\n        {\n            cout &lt;&lt; obj[i][j] &lt;&lt; &quot; &quot;;\n        }\n        cout &lt;&lt; &quot;\\n&quot;;\n    }\n    return 0;\n}\n</code></pre>\n<h4 id=\"h4-u7ED3u6784u4F53u7C7Bu578Bu5143u7D20\"><a name=\"结构体类型元素\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>结构体类型元素</h4><blockquote>\n<p> 注意⚠：结构体要定义为全局！</p>\n</blockquote>\n<pre><code class=\"lang-c++\">#include&lt;stdio.h&gt;  \n#include&lt;algorithm&gt;  \n#include&lt;vector&gt;  \n#include&lt;iostream&gt;  \nusing namespace std;  \ntypedef struct rect  \n{  \n    int id;  \n    int length;  \n    int width;  \n　　//对于向量元素是结构体的，可在结构体内部定义比较函数，下面按照id,length,width升序排序。  \n　　bool operator&lt; (const rect &amp;a)  const  \n    {  \n        if(id!=a.id)  \n            return id&lt;a.id;  \n        else  \n        {  \n            if(length!=a.length)  \n                return length&lt;a.length;  \n            else  \n                return width&lt;a.width;  \n        }  \n    }  \n}Rect;  \nint main()  \n{  \n    vector&lt;Rect&gt; vec;  \n    Rect rect;  \n    rect.id=1;  \n    rect.length=2;  \n    rect.width=3;  \n    vec.push_back(rect);  \n    vector&lt;Rect&gt;::iterator it=vec.begin();  \n    cout&lt;&lt;(*it).id&lt;&lt;&#39; &#39;&lt;&lt;(*it).length&lt;&lt;&#39; &#39;&lt;&lt;(*it).width&lt;&lt;endl;      \nreturn 0;  \n}\n</code></pre>\n', '2020-07-22', '2020-07-22', '0');
INSERT INTO `article_info` VALUES ('76', '系统测试', '1', '# MD语法测试\n\n> 代码高亮测试\n\n```c++\n#include <iostream>\n\nint main(){\n\n	int a;\n	\n	printf(\"123!\");\n\n	return 0;\n}\n```\n\n> 图片测试\n\n![TIM截图20200723144654.png](https://i.loli.net/2020/07/23/s85JoqLwH69GlZT.png)\n\n:fa-glass: :fa-music: :fa-search: :fa-envelope-o: :fa-heart: :fa-star: :fa-star-o: :fa-user:', '<h1 id=\"h1-md-\"><a name=\"MD语法测试\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>MD语法测试</h1><blockquote>\n<p>代码高亮测试</p>\n</blockquote>\n<pre><code class=\"lang-c++\">#include &lt;iostream&gt;\n\nint main(){\n\n    int a;\n\n    printf(&quot;123!&quot;);\n\n    return 0;\n}\n</code></pre>\n<blockquote>\n<p>图片测试</p>\n</blockquote>\n<p><img src=\"https://i.loli.net/2020/07/23/s85JoqLwH69GlZT.png\" alt=\"TIM截图20200723144654.png\"></p>\n<p><i class=\"fa fa-glass fa-emoji\" title=\"glass\"></i> <i class=\"fa fa-music fa-emoji\" title=\"music\"></i> <i class=\"fa fa-search fa-emoji\" title=\"search\"></i> <i class=\"fa fa-envelope-o fa-emoji\" title=\"envelope-o\"></i> <i class=\"fa fa-heart fa-emoji\" title=\"heart\"></i> <i class=\"fa fa-star fa-emoji\" title=\"star\"></i> <i class=\"fa fa-star-o fa-emoji\" title=\"star-o\"></i> <i class=\"fa fa-user fa-emoji\" title=\"user\"></i></p>\n', '2020-07-22', '2020-07-22', '0');
INSERT INTO `article_info` VALUES ('77', '123', '56', '789\n\n> 第一次更新\n\n![nattu-adnan-Ai2TRdvI6gM-unsplash.jpg](https://i.loli.net/2020/07/23/rxBNhLO5qCVKfco.jpg)\n\n# 123', '<p>789</p>\n<blockquote>\n<p>第一次更新</p>\n</blockquote>\n<p><img src=\"https://i.loli.net/2020/07/23/rxBNhLO5qCVKfco.jpg\" alt=\"nattu-adnan-Ai2TRdvI6gM-unsplash.jpg\"></p>\n<h1 id=\"h1-123\"><a name=\"123\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>123</h1>', '2020-07-23', '2020-07-23', '1');
INSERT INTO `article_info` VALUES ('78', 'www', '59', 'dfs', '<p>dfs</p>\n', '2020-07-23', '2020-07-23', '1');
INSERT INTO `article_info` VALUES ('79', '新建测试', '56', ' # 测试\n \n ## 修改文章\n \n```c++\n#include <>\nxxxx\n```', '<h1 id=\"h1-u6D4Bu8BD5\"><a name=\"测试\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>测试</h1><h2 id=\"h2-u4FEEu6539u6587u7AE0\"><a name=\"修改文章\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>修改文章</h2><pre><code class=\"lang-c++\">#include &lt;&gt;\nxxxx\n</code></pre>\n', '2020-07-23', '2020-07-23', '1');
INSERT INTO `article_info` VALUES ('80', '新建文章测试', '1', '# 测试\n\n> 文章修改\n\n```c\n#include <xxx>\n\nreturn 0;\n```', '<h1 id=\"h1-u6D4Bu8BD5\"><a name=\"测试\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>测试</h1><blockquote>\n<p>文章修改</p>\n</blockquote>\n<pre><code class=\"lang-c\">#include &lt;xxx&gt;\n\nreturn 0;\n</code></pre>\n', '2020-07-23', '2020-07-23', '1');
INSERT INTO `article_info` VALUES ('81', '上下', '1', '得到大大', '<p>得到大大</p>\n', '2020-07-23', '2020-07-23', '1');

-- ----------------------------
-- Table structure for class_info
-- ----------------------------
DROP TABLE IF EXISTS `class_info`;
CREATE TABLE `class_info` (
  `class_id` int(11) NOT NULL AUTO_INCREMENT,
  `class_name` varchar(255) NOT NULL,
  `class_del` int(1) NOT NULL DEFAULT '0',
  PRIMARY KEY (`class_id`,`class_name`),
  KEY `class_id` (`class_id`)
) ENGINE=InnoDB AUTO_INCREMENT=60 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of class_info
-- ----------------------------
INSERT INTO `class_info` VALUES ('1', '测试', '0');
INSERT INTO `class_info` VALUES ('53', '笔记', '0');
INSERT INTO `class_info` VALUES ('54', '数据结构', '0');
INSERT INTO `class_info` VALUES ('55', 'python库', '0');
INSERT INTO `class_info` VALUES ('56', '算法', '0');
INSERT INTO `class_info` VALUES ('57', '实验模拟', '0');
INSERT INTO `class_info` VALUES ('58', '区块链', '0');
INSERT INTO `class_info` VALUES ('59', 'qw', '1');

-- ----------------------------
-- Table structure for remark_info
-- ----------------------------
DROP TABLE IF EXISTS `remark_info`;
CREATE TABLE `remark_info` (
  `remark_id` int(11) NOT NULL AUTO_INCREMENT,
  `remark_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `remark_context` longtext,
  `remark_aid` int(11) DEFAULT NULL,
  `remark_date` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `remark_del` int(11) NOT NULL DEFAULT '0',
  PRIMARY KEY (`remark_id`),
  KEY `remark_aid` (`remark_aid`),
  CONSTRAINT `remark_aid` FOREIGN KEY (`remark_aid`) REFERENCES `article_info` (`a_id`)
) ENGINE=InnoDB AUTO_INCREMENT=36 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of remark_info
-- ----------------------------
INSERT INTO `remark_info` VALUES ('28', '崔酱', '鲁迅什么都说过。', '68', '2020-07-23', '0');
INSERT INTO `remark_info` VALUES ('29', '鲁迅', '没有，我没说过。', '68', '2020-07-23', '0');
INSERT INTO `remark_info` VALUES ('30', '哇哇哇', '12345', '77', '2020-07-23', '1');
INSERT INTO `remark_info` VALUES ('31', '微软', '微软', '77', '2020-07-23', '1');
INSERT INTO `remark_info` VALUES ('32', '游客1', '查看文章', '79', '2020-07-23', '1');
INSERT INTO `remark_info` VALUES ('33', '游客2', '查看', '79', '2020-07-23', '1');
INSERT INTO `remark_info` VALUES ('34', '游客1', '文章', '80', '2020-07-23', '1');
INSERT INTO `remark_info` VALUES ('35', '游客2', '查看', '80', '2020-07-23', '1');

-- ----------------------------
-- View structure for class_number
-- ----------------------------
DROP VIEW IF EXISTS `class_number`;
CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `class_number` AS select `cla`.`class_id` AS `class_id`,`cla`.`class_name` AS `class_name`,count(0) AS `num` from (`article_info` `art` join `class_info` `cla`) where ((`art`.`a_cid` = `cla`.`class_id`) and (`art`.`a_del` = 0)) group by `cla`.`class_id`,`cla`.`class_name` ;

-- ----------------------------
-- Procedure structure for pro_class
-- ----------------------------
DROP PROCEDURE IF EXISTS `pro_class`;
DELIMITER ;;
CREATE DEFINER=`root`@`localhost` PROCEDURE `pro_class`(IN `cname` varchar(50))
BEGIN
	#Routine body goes here...
	DECLARE n int(11);
	select class_id into n from class_info where class_name=cname;
	if n is NULL then
			insert into class_info(class_name) values(cname);
	end if;
END
;;
DELIMITER ;
